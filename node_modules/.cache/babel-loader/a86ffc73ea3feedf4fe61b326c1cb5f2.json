{"ast":null,"code":"import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */function () {\n  function PDFObjectCopier(src, dest) {\n    var _this = this;\n    this.traversedObjects = new Map();\n    // prettier-ignore\n    this.copy = function (object) {\n      return object instanceof PDFPageLeaf ? _this.copyPDFPage(object) : object instanceof PDFDict ? _this.copyPDFDict(object) : object instanceof PDFArray ? _this.copyPDFArray(object) : object instanceof PDFStream ? _this.copyPDFStream(object) : object instanceof PDFRef ? _this.copyPDFIndirectObject(object) : object.clone();\n    };\n    this.copyPDFPage = function (originalPage) {\n      var clonedPage = originalPage.clone();\n      // Move any entries that the originalPage is inheriting from its parent\n      // tree nodes directly into originalPage so they are preserved during\n      // the copy.\n      var InheritableEntries = PDFPageLeaf.InheritableEntries;\n      for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n        var key = PDFName.of(InheritableEntries[idx]);\n        var value = clonedPage.getInheritableAttribute(key);\n        if (!clonedPage.get(key) && value) clonedPage.set(key, value);\n      }\n      // Remove the parent reference to prevent the whole donor document's page\n      // tree from being copied when we only need a single page.\n      clonedPage.delete(PDFName.of('Parent'));\n      return _this.copyPDFDict(clonedPage);\n    };\n    this.copyPDFDict = function (originalDict) {\n      if (_this.traversedObjects.has(originalDict)) {\n        return _this.traversedObjects.get(originalDict);\n      }\n      var clonedDict = originalDict.clone(_this.dest);\n      _this.traversedObjects.set(originalDict, clonedDict);\n      var entries = originalDict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedDict.set(key, _this.copy(value));\n      }\n      return clonedDict;\n    };\n    this.copyPDFArray = function (originalArray) {\n      if (_this.traversedObjects.has(originalArray)) {\n        return _this.traversedObjects.get(originalArray);\n      }\n      var clonedArray = originalArray.clone(_this.dest);\n      _this.traversedObjects.set(originalArray, clonedArray);\n      for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n        var value = originalArray.get(idx);\n        clonedArray.set(idx, _this.copy(value));\n      }\n      return clonedArray;\n    };\n    this.copyPDFStream = function (originalStream) {\n      if (_this.traversedObjects.has(originalStream)) {\n        return _this.traversedObjects.get(originalStream);\n      }\n      var clonedStream = originalStream.clone(_this.dest);\n      _this.traversedObjects.set(originalStream, clonedStream);\n      var entries = originalStream.dict.entries();\n      for (var idx = 0, len = entries.length; idx < len; idx++) {\n        var _a = entries[idx],\n          key = _a[0],\n          value = _a[1];\n        clonedStream.dict.set(key, _this.copy(value));\n      }\n      return clonedStream;\n    };\n    this.copyPDFIndirectObject = function (ref) {\n      var alreadyMapped = _this.traversedObjects.has(ref);\n      if (!alreadyMapped) {\n        var newRef = _this.dest.nextRef();\n        _this.traversedObjects.set(ref, newRef);\n        var dereferencedValue = _this.src.lookup(ref);\n        if (dereferencedValue) {\n          var cloned = _this.copy(dereferencedValue);\n          _this.dest.assign(newRef, cloned);\n        }\n      }\n      return _this.traversedObjects.get(ref);\n    };\n    this.src = src;\n    this.dest = dest;\n  }\n  PDFObjectCopier.for = function (src, dest) {\n    return new PDFObjectCopier(src, dest);\n  };\n  return PDFObjectCopier;\n}();\nexport default PDFObjectCopier;","map":{"version":3,"sources":["../../src/core/PDFObjectCopier.ts"],"names":[],"mappings":"AAAA,OAAO,QAAQ,MAAA,oBAAA;AACf,OAAO,OAAO,MAAA,mBAAA;AACd,OAAO,OAAO,MAAA,mBAAA;AAEd,OAAO,MAAM,MAAA,kBAAA;AACb,OAAO,SAAS,MAAA,qBAAA;AAEhB,OAAO,WAAW,MAAA,0BAAA;AAElB;;;;;;;;;;;;;;;;;;;;AAoBG;AACH,IAAA,eAAA,GAAA,aAAA,YAAA;EAQE,SAAA,eAAA,CAAoB,GAAe,EAAE,IAAgB,EAAA;IAArD,IAAA,KAAA,GAAA,IAAA;IAFiB,IAAA,CAAA,gBAAgB,GAAG,IAAI,GAAG,CAAA,CAAwB;IAOnE;IACA,IAAA,CAAA,IAAI,GAAG,UAAsB,MAAS,EAAA;MAAQ,OAC1C,MAAM,YAAY,WAAW,GAAG,KAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GACxD,MAAM,YAAY,OAAO,GAAO,KAAI,CAAC,WAAW,CAAC,MAAM,CAAC,GACxD,MAAM,YAAY,QAAQ,GAAM,KAAI,CAAC,YAAY,CAAC,MAAM,CAAC,GACzD,MAAM,YAAY,SAAS,GAAK,KAAI,CAAC,aAAa,CAAC,MAAM,CAAC,GAC1D,MAAM,YAAY,MAAM,GAAQ,KAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,GAClE,MAAM,CAAC,KAAK,CAAA,CAAE;IAN4B,CAOxC;IAEE,IAAA,CAAA,WAAW,GAAG,UAAC,YAAyB,EAAA;MAC9C,IAAM,UAAU,GAAG,YAAY,CAAC,KAAK,CAAA,CAAE;MAEvC;MACA;MACA;MACQ,IAAA,kBAAkB,GAAK,WAAW,CAAA,kBAAhB;MAC1B,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,kBAAkB,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE;QACnE,IAAM,GAAG,GAAG,OAAO,CAAC,EAAE,CAAC,kBAAkB,CAAC,GAAG,CAAC,CAAC;QAC/C,IAAM,KAAK,GAAG,UAAU,CAAC,uBAAuB,CAAC,GAAG,CAAE;QACtD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,KAAK,EAAE,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,KAAK,CAAC;MAC9D;MAED;MACA;MACA,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;MAEvC,OAAO,KAAI,CAAC,WAAW,CAAC,UAAU,CAAgB;IACpD,CAAC;IAEO,IAAA,CAAA,WAAW,GAAG,UAAC,YAAqB,EAAA;MAC1C,IAAI,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;QAC3C,OAAO,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,CAAY;MAC1D;MAED,IAAM,UAAU,GAAG,YAAY,CAAC,KAAK,CAAC,KAAI,CAAC,IAAI,CAAC;MAChD,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,YAAY,EAAE,UAAU,CAAC;MAEnD,IAAM,OAAO,GAAG,YAAY,CAAC,OAAO,CAAA,CAAE;MAEtC,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE;QAClD,IAAA,EAAA,GAAe,OAAO,CAAC,GAAG,CAAC;UAA1B,GAAG,GAAA,EAAA,CAAA,CAAA,CAAA;UAAE,KAAK,GAAA,EAAA,CAAA,CAAA,CAAgB;QACjC,UAAU,CAAC,GAAG,CAAC,GAAG,EAAE,KAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;MACtC;MAED,OAAO,UAAU;IACnB,CAAC;IAEO,IAAA,CAAA,YAAY,GAAG,UAAC,aAAuB,EAAA;MAC7C,IAAI,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,aAAa,CAAC,EAAE;QAC5C,OAAO,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,aAAa,CAAa;MAC5D;MAED,IAAM,WAAW,GAAG,aAAa,CAAC,KAAK,CAAC,KAAI,CAAC,IAAI,CAAC;MAClD,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,aAAa,EAAE,WAAW,CAAC;MAErD,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,aAAa,CAAC,IAAI,CAAA,CAAE,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE;QAC9D,IAAM,KAAK,GAAG,aAAa,CAAC,GAAG,CAAC,GAAG,CAAC;QACpC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,KAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;MACvC;MAED,OAAO,WAAW;IACpB,CAAC;IAEO,IAAA,CAAA,aAAa,GAAG,UAAC,cAAyB,EAAA;MAChD,IAAI,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,CAAC,EAAE;QAC7C,OAAO,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,CAAc;MAC9D;MAED,IAAM,YAAY,GAAG,cAAc,CAAC,KAAK,CAAC,KAAI,CAAC,IAAI,CAAC;MACpD,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,cAAc,EAAE,YAAY,CAAC;MAEvD,IAAM,OAAO,GAAG,cAAc,CAAC,IAAI,CAAC,OAAO,CAAA,CAAE;MAC7C,KAAK,IAAI,GAAG,GAAG,CAAC,EAAE,GAAG,GAAG,OAAO,CAAC,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAG,EAAE,EAAE;QAClD,IAAA,EAAA,GAAe,OAAO,CAAC,GAAG,CAAC;UAA1B,GAAG,GAAA,EAAA,CAAA,CAAA,CAAA;UAAE,KAAK,GAAA,EAAA,CAAA,CAAA,CAAgB;QACjC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,KAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;MAC7C;MAED,OAAO,YAAY;IACrB,CAAC;IAEO,IAAA,CAAA,qBAAqB,GAAG,UAAC,GAAW,EAAA;MAC1C,IAAM,aAAa,GAAG,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAC;MAEpD,IAAI,CAAC,aAAa,EAAE;QAClB,IAAM,MAAM,GAAG,KAAI,CAAC,IAAI,CAAC,OAAO,CAAA,CAAE;QAClC,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC;QAEtC,IAAM,iBAAiB,GAAG,KAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC;QAC9C,IAAI,iBAAiB,EAAE;UACrB,IAAM,MAAM,GAAG,KAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;UAC3C,KAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;QACjC;MACF;MAED,OAAO,KAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,GAAG,CAAW;IACjD,CAAC;IApGC,IAAI,CAAC,GAAG,GAAG,GAAG;IACd,IAAI,CAAC,IAAI,GAAG,IAAI;EAClB;EAVO,eAAA,CAAA,GAAG,GAAG,UAAC,GAAe,EAAE,IAAgB,EAAA;IAC7C,OAAA,IAAI,eAAe,CAAC,GAAG,EAAE,IAAI,CAAC;EAA9B,CAA8B;EA4GlC,OAAA,eAAC;CAAA,CAAA,CAAA;AAED,eAAe,eAAe","sourceRoot":"","sourcesContent":["import PDFArray from \"./objects/PDFArray\";\nimport PDFDict from \"./objects/PDFDict\";\nimport PDFName from \"./objects/PDFName\";\nimport PDFRef from \"./objects/PDFRef\";\nimport PDFStream from \"./objects/PDFStream\";\nimport PDFPageLeaf from \"./structures/PDFPageLeaf\";\n/**\n * PDFObjectCopier copies PDFObjects from a src context to a dest context.\n * The primary use case for this is to copy pages between PDFs.\n *\n * _Copying_ an object with a PDFObjectCopier is different from _cloning_ an\n * object with its [[PDFObject.clone]] method:\n *\n * ```\n *   const src: PDFContext = ...\n *   const dest: PDFContext = ...\n *   const originalObject: PDFObject = ...\n *   const copiedObject = PDFObjectCopier.for(src, dest).copy(originalObject);\n *   const clonedObject = originalObject.clone();\n * ```\n *\n * Copying an object is equivalent to cloning it and then copying over any other\n * objects that it references. Note that only dictionaries, arrays, and streams\n * (or structures build from them) can contain indirect references to other\n * objects. Copying a PDFObject that is not a dictionary, array, or stream is\n * supported, but is equivalent to cloning it.\n */\nvar PDFObjectCopier = /** @class */ (function () {\n    function PDFObjectCopier(src, dest) {\n        var _this = this;\n        this.traversedObjects = new Map();\n        // prettier-ignore\n        this.copy = function (object) { return (object instanceof PDFPageLeaf ? _this.copyPDFPage(object)\n            : object instanceof PDFDict ? _this.copyPDFDict(object)\n                : object instanceof PDFArray ? _this.copyPDFArray(object)\n                    : object instanceof PDFStream ? _this.copyPDFStream(object)\n                        : object instanceof PDFRef ? _this.copyPDFIndirectObject(object)\n                            : object.clone()); };\n        this.copyPDFPage = function (originalPage) {\n            var clonedPage = originalPage.clone();\n            // Move any entries that the originalPage is inheriting from its parent\n            // tree nodes directly into originalPage so they are preserved during\n            // the copy.\n            var InheritableEntries = PDFPageLeaf.InheritableEntries;\n            for (var idx = 0, len = InheritableEntries.length; idx < len; idx++) {\n                var key = PDFName.of(InheritableEntries[idx]);\n                var value = clonedPage.getInheritableAttribute(key);\n                if (!clonedPage.get(key) && value)\n                    clonedPage.set(key, value);\n            }\n            // Remove the parent reference to prevent the whole donor document's page\n            // tree from being copied when we only need a single page.\n            clonedPage.delete(PDFName.of('Parent'));\n            return _this.copyPDFDict(clonedPage);\n        };\n        this.copyPDFDict = function (originalDict) {\n            if (_this.traversedObjects.has(originalDict)) {\n                return _this.traversedObjects.get(originalDict);\n            }\n            var clonedDict = originalDict.clone(_this.dest);\n            _this.traversedObjects.set(originalDict, clonedDict);\n            var entries = originalDict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedDict.set(key, _this.copy(value));\n            }\n            return clonedDict;\n        };\n        this.copyPDFArray = function (originalArray) {\n            if (_this.traversedObjects.has(originalArray)) {\n                return _this.traversedObjects.get(originalArray);\n            }\n            var clonedArray = originalArray.clone(_this.dest);\n            _this.traversedObjects.set(originalArray, clonedArray);\n            for (var idx = 0, len = originalArray.size(); idx < len; idx++) {\n                var value = originalArray.get(idx);\n                clonedArray.set(idx, _this.copy(value));\n            }\n            return clonedArray;\n        };\n        this.copyPDFStream = function (originalStream) {\n            if (_this.traversedObjects.has(originalStream)) {\n                return _this.traversedObjects.get(originalStream);\n            }\n            var clonedStream = originalStream.clone(_this.dest);\n            _this.traversedObjects.set(originalStream, clonedStream);\n            var entries = originalStream.dict.entries();\n            for (var idx = 0, len = entries.length; idx < len; idx++) {\n                var _a = entries[idx], key = _a[0], value = _a[1];\n                clonedStream.dict.set(key, _this.copy(value));\n            }\n            return clonedStream;\n        };\n        this.copyPDFIndirectObject = function (ref) {\n            var alreadyMapped = _this.traversedObjects.has(ref);\n            if (!alreadyMapped) {\n                var newRef = _this.dest.nextRef();\n                _this.traversedObjects.set(ref, newRef);\n                var dereferencedValue = _this.src.lookup(ref);\n                if (dereferencedValue) {\n                    var cloned = _this.copy(dereferencedValue);\n                    _this.dest.assign(newRef, cloned);\n                }\n            }\n            return _this.traversedObjects.get(ref);\n        };\n        this.src = src;\n        this.dest = dest;\n    }\n    PDFObjectCopier.for = function (src, dest) {\n        return new PDFObjectCopier(src, dest);\n    };\n    return PDFObjectCopier;\n}());\nexport default PDFObjectCopier;\n//# sourceMappingURL=PDFObjectCopier.js.map"]},"metadata":{},"sourceType":"module"}