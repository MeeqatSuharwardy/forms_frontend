{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, toHexStringOfMinLength, utf16Decode, utf16Encode, pdfDocEncodingDecode, parseDate, hasUtf16BOM } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\nvar PDFHexString = /** @class */function (_super) {\n  __extends(PDFHexString, _super);\n  function PDFHexString(value) {\n    var _this = _super.call(this) || this;\n    _this.value = value;\n    return _this;\n  }\n  PDFHexString.prototype.asBytes = function () {\n    // Append a zero if the number of digits is odd. See PDF spec 7.3.4.3\n    var hex = this.value + (this.value.length % 2 === 1 ? '0' : '');\n    var hexLength = hex.length;\n    var bytes = new Uint8Array(hex.length / 2);\n    var hexOffset = 0;\n    var bytesOffset = 0;\n    // Interpret each pair of hex digits as a single byte\n    while (hexOffset < hexLength) {\n      var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);\n      bytes[bytesOffset] = byte;\n      hexOffset += 2;\n      bytesOffset += 1;\n    }\n    return bytes;\n  };\n  PDFHexString.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    if (hasUtf16BOM(bytes)) return utf16Decode(bytes);\n    return pdfDocEncodingDecode(bytes);\n  };\n  PDFHexString.prototype.decodeDate = function () {\n    var text = this.decodeText();\n    var date = parseDate(text);\n    if (!date) throw new InvalidPDFDateStringError(text);\n    return date;\n  };\n  PDFHexString.prototype.asString = function () {\n    return this.value;\n  };\n  PDFHexString.prototype.clone = function () {\n    return PDFHexString.of(this.value);\n  };\n  PDFHexString.prototype.toString = function () {\n    return \"<\" + this.value + \">\";\n  };\n  PDFHexString.prototype.sizeInBytes = function () {\n    return this.value.length + 2;\n  };\n  PDFHexString.prototype.copyBytesInto = function (buffer, offset) {\n    buffer[offset++] = CharCodes.LessThan;\n    offset += copyStringIntoBuffer(this.value, buffer, offset);\n    buffer[offset++] = CharCodes.GreaterThan;\n    return this.value.length + 2;\n  };\n  PDFHexString.of = function (value) {\n    return new PDFHexString(value);\n  };\n  PDFHexString.fromText = function (value) {\n    var encoded = utf16Encode(value);\n    var hex = '';\n    for (var idx = 0, len = encoded.length; idx < len; idx++) {\n      hex += toHexStringOfMinLength(encoded[idx], 4);\n    }\n    return new PDFHexString(hex);\n  };\n  return PDFHexString;\n}(PDFObject);\nexport default PDFHexString;","map":{"version":3,"sources":["../../../src/core/objects/PDFHexString.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, toHexStringOfMinLength, utf16Decode, utf16Encode, pdfDocEncodingDecode, parseDate, hasUtf16BOM, } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\nvar PDFHexString = /** @class */ (function (_super) {\n    __extends(PDFHexString, _super);\n    function PDFHexString(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        return _this;\n    }\n    PDFHexString.prototype.asBytes = function () {\n        // Append a zero if the number of digits is odd. See PDF spec 7.3.4.3\n        var hex = this.value + (this.value.length % 2 === 1 ? '0' : '');\n        var hexLength = hex.length;\n        var bytes = new Uint8Array(hex.length / 2);\n        var hexOffset = 0;\n        var bytesOffset = 0;\n        // Interpret each pair of hex digits as a single byte\n        while (hexOffset < hexLength) {\n            var byte = parseInt(hex.substring(hexOffset, hexOffset + 2), 16);\n            bytes[bytesOffset] = byte;\n            hexOffset += 2;\n            bytesOffset += 1;\n        }\n        return bytes;\n    };\n    PDFHexString.prototype.decodeText = function () {\n        var bytes = this.asBytes();\n        if (hasUtf16BOM(bytes))\n            return utf16Decode(bytes);\n        return pdfDocEncodingDecode(bytes);\n    };\n    PDFHexString.prototype.decodeDate = function () {\n        var text = this.decodeText();\n        var date = parseDate(text);\n        if (!date)\n            throw new InvalidPDFDateStringError(text);\n        return date;\n    };\n    PDFHexString.prototype.asString = function () {\n        return this.value;\n    };\n    PDFHexString.prototype.clone = function () {\n        return PDFHexString.of(this.value);\n    };\n    PDFHexString.prototype.toString = function () {\n        return \"<\" + this.value + \">\";\n    };\n    PDFHexString.prototype.sizeInBytes = function () {\n        return this.value.length + 2;\n    };\n    PDFHexString.prototype.copyBytesInto = function (buffer, offset) {\n        buffer[offset++] = CharCodes.LessThan;\n        offset += copyStringIntoBuffer(this.value, buffer, offset);\n        buffer[offset++] = CharCodes.GreaterThan;\n        return this.value.length + 2;\n    };\n    PDFHexString.of = function (value) { return new PDFHexString(value); };\n    PDFHexString.fromText = function (value) {\n        var encoded = utf16Encode(value);\n        var hex = '';\n        for (var idx = 0, len = encoded.length; idx < len; idx++) {\n            hex += toHexStringOfMinLength(encoded[idx], 4);\n        }\n        return new PDFHexString(hex);\n    };\n    return PDFHexString;\n}(PDFObject));\nexport default PDFHexString;\n//# sourceMappingURL=PDFHexString.js.map"]},"metadata":{},"sourceType":"module"}