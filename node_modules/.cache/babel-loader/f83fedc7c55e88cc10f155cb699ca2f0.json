{"ast":null,"code":"/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar RunLengthStream = /** @class */function (_super) {\n  __extends(RunLengthStream, _super);\n  function RunLengthStream(stream, maybeLength) {\n    var _this = _super.call(this, maybeLength) || this;\n    _this.stream = stream;\n    return _this;\n  }\n  RunLengthStream.prototype.readBlock = function () {\n    // The repeatHeader has following format. The first byte defines type of run\n    // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n    // (in addition to the second byte from the header), n = 129 through 255 -\n    // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n    var repeatHeader = this.stream.getBytes(2);\n    if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n      this.eof = true;\n      return;\n    }\n    var buffer;\n    var bufferLength = this.bufferLength;\n    var n = repeatHeader[0];\n    if (n < 128) {\n      // copy n bytes\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      buffer[bufferLength++] = repeatHeader[1];\n      if (n > 0) {\n        var source = this.stream.getBytes(n);\n        buffer.set(source, bufferLength);\n        bufferLength += n;\n      }\n    } else {\n      n = 257 - n;\n      var b = repeatHeader[1];\n      buffer = this.ensureBuffer(bufferLength + n + 1);\n      for (var i = 0; i < n; i++) {\n        buffer[bufferLength++] = b;\n      }\n    }\n    this.bufferLength = bufferLength;\n  };\n  return RunLengthStream;\n}(DecodeStream);\nexport default RunLengthStream;","map":{"version":3,"sources":["../../../src/core/streams/RunLengthStream.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;AAEH,OAAO,YAAY,MAAA,gBAAA;AAGnB,IAAA,eAAA,GAAA,aAAA,UAAA,MAAA,EAAA;EAA8B,SAAA,CAAA,eAAA,EAAA,MAAA,CAAA;EAG5B,SAAA,eAAA,CAAY,MAAkB,EAAE,WAAoB,EAAA;IAApD,IAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,WAAW,CAAC,IAAA,IAAA;IAClB,KAAI,CAAC,MAAM,GAAG,MAAM;;EACtB;EAEU,eAAA,CAAA,SAAA,CAAA,SAAS,GAAnB,YAAA;IACE;IACA;IACA;IACA;IACA,IAAM,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5C,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,YAAY,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACvE,IAAI,CAAC,GAAG,GAAG,IAAI;MACf;IACD;IAED,IAAI,MAAM;IACV,IAAI,YAAY,GAAG,IAAI,CAAC,YAAY;IACpC,IAAI,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC;IACvB,IAAI,CAAC,GAAG,GAAG,EAAE;MACX;MACA,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;MAChD,MAAM,CAAC,YAAY,EAAE,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC;MACxC,IAAI,CAAC,GAAG,CAAC,EAAE;QACT,IAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC;QACtC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,YAAY,CAAC;QAChC,YAAY,IAAI,CAAC;MAClB;KACF,MAAM;MACL,CAAC,GAAG,GAAG,GAAG,CAAC;MACX,IAAM,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC;MACzB,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;MAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QAC1B,MAAM,CAAC,YAAY,EAAE,CAAC,GAAG,CAAC;MAC3B;IACF;IACD,IAAI,CAAC,YAAY,GAAG,YAAY;EAClC,CAAC;EACH,OAAA,eAAC;AAAD,CAAC,CAzC6B,YAAY,CAAA;AA2C1C,eAAe,eAAe","sourceRoot":"","sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The RunLengthStream class contained in this file is a TypeScript port of the\n * JavaScript RunLengthStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar RunLengthStream = /** @class */ (function (_super) {\n    __extends(RunLengthStream, _super);\n    function RunLengthStream(stream, maybeLength) {\n        var _this = _super.call(this, maybeLength) || this;\n        _this.stream = stream;\n        return _this;\n    }\n    RunLengthStream.prototype.readBlock = function () {\n        // The repeatHeader has following format. The first byte defines type of run\n        // and amount of bytes to repeat/copy: n = 0 through 127 - copy next n bytes\n        // (in addition to the second byte from the header), n = 129 through 255 -\n        // duplicate the second byte from the header (257 - n) times, n = 128 - end.\n        var repeatHeader = this.stream.getBytes(2);\n        if (!repeatHeader || repeatHeader.length < 2 || repeatHeader[0] === 128) {\n            this.eof = true;\n            return;\n        }\n        var buffer;\n        var bufferLength = this.bufferLength;\n        var n = repeatHeader[0];\n        if (n < 128) {\n            // copy n bytes\n            buffer = this.ensureBuffer(bufferLength + n + 1);\n            buffer[bufferLength++] = repeatHeader[1];\n            if (n > 0) {\n                var source = this.stream.getBytes(n);\n                buffer.set(source, bufferLength);\n                bufferLength += n;\n            }\n        }\n        else {\n            n = 257 - n;\n            var b = repeatHeader[1];\n            buffer = this.ensureBuffer(bufferLength + n + 1);\n            for (var i = 0; i < n; i++) {\n                buffer[bufferLength++] = b;\n            }\n        }\n        this.bufferLength = bufferLength;\n    };\n    return RunLengthStream;\n}(DecodeStream));\nexport default RunLengthStream;\n//# sourceMappingURL=RunLengthStream.js.map"]},"metadata":{},"sourceType":"module"}