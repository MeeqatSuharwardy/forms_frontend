{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */function (_super) {\n  __extends(PDFObjectParser, _super);\n  function PDFObjectParser(byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, byteStream, capNumbers) || this;\n    _this.context = context;\n    return _this;\n  }\n  // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n  PDFObjectParser.prototype.parseObject = function () {\n    this.skipWhitespaceAndComments();\n    if (this.matchKeyword(Keywords.true)) return PDFBool.True;\n    if (this.matchKeyword(Keywords.false)) return PDFBool.False;\n    if (this.matchKeyword(Keywords.null)) return PDFNull;\n    var byte = this.bytes.peek();\n    if (byte === CharCodes.LessThan && this.bytes.peekAhead(1) === CharCodes.LessThan) {\n      return this.parseDictOrStream();\n    }\n    if (byte === CharCodes.LessThan) return this.parseHexString();\n    if (byte === CharCodes.LeftParen) return this.parseString();\n    if (byte === CharCodes.ForwardSlash) return this.parseName();\n    if (byte === CharCodes.LeftSquareBracket) return this.parseArray();\n    if (IsNumeric[byte]) return this.parseNumberOrRef();\n    throw new PDFObjectParsingError(this.bytes.position(), byte);\n  };\n  PDFObjectParser.prototype.parseNumberOrRef = function () {\n    var firstNum = this.parseRawNumber();\n    this.skipWhitespaceAndComments();\n    var lookaheadStart = this.bytes.offset();\n    if (IsDigit[this.bytes.peek()]) {\n      var secondNum = this.parseRawNumber();\n      this.skipWhitespaceAndComments();\n      if (this.bytes.peek() === CharCodes.R) {\n        this.bytes.assertNext(CharCodes.R);\n        return PDFRef.of(firstNum, secondNum);\n      }\n    }\n    this.bytes.moveTo(lookaheadStart);\n    return PDFNumber.of(firstNum);\n  };\n  // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n  PDFObjectParser.prototype.parseHexString = function () {\n    var value = '';\n    this.bytes.assertNext(CharCodes.LessThan);\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n      value += charFromCode(this.bytes.next());\n    }\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    return PDFHexString.of(value);\n  };\n  PDFObjectParser.prototype.parseString = function () {\n    var nestingLvl = 0;\n    var isEscaped = false;\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.next();\n      value += charFromCode(byte);\n      // Check for unescaped parenthesis\n      if (!isEscaped) {\n        if (byte === CharCodes.LeftParen) nestingLvl += 1;\n        if (byte === CharCodes.RightParen) nestingLvl -= 1;\n      }\n      // Track whether current character is being escaped or not\n      if (byte === CharCodes.BackSlash) {\n        isEscaped = !isEscaped;\n      } else if (isEscaped) {\n        isEscaped = false;\n      }\n      // Once (if) the unescaped parenthesis balance out, return their contents\n      if (nestingLvl === 0) {\n        // Remove the outer parens so they aren't part of the contents\n        return PDFString.of(value.substring(1, value.length - 1));\n      }\n    }\n    throw new UnbalancedParenthesisError(this.bytes.position());\n  };\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n  PDFObjectParser.prototype.parseName = function () {\n    this.bytes.assertNext(CharCodes.ForwardSlash);\n    var name = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (IsWhitespace[byte] || IsDelimiter[byte]) break;\n      name += charFromCode(byte);\n      this.bytes.next();\n    }\n    return PDFName.of(name);\n  };\n  PDFObjectParser.prototype.parseArray = function () {\n    this.bytes.assertNext(CharCodes.LeftSquareBracket);\n    this.skipWhitespaceAndComments();\n    var pdfArray = PDFArray.withContext(this.context);\n    while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n      var element = this.parseObject();\n      pdfArray.push(element);\n      this.skipWhitespaceAndComments();\n    }\n    this.bytes.assertNext(CharCodes.RightSquareBracket);\n    return pdfArray;\n  };\n  PDFObjectParser.prototype.parseDict = function () {\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.bytes.assertNext(CharCodes.LessThan);\n    this.skipWhitespaceAndComments();\n    var dict = new Map();\n    while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan && this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n      var key = this.parseName();\n      var value = this.parseObject();\n      dict.set(key, value);\n      this.skipWhitespaceAndComments();\n    }\n    this.skipWhitespaceAndComments();\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    this.bytes.assertNext(CharCodes.GreaterThan);\n    var Type = dict.get(PDFName.of('Type'));\n    if (Type === PDFName.of('Catalog')) {\n      return PDFCatalog.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Pages')) {\n      return PDFPageTree.fromMapWithContext(dict, this.context);\n    } else if (Type === PDFName.of('Page')) {\n      return PDFPageLeaf.fromMapWithContext(dict, this.context);\n    } else {\n      return PDFDict.fromMapWithContext(dict, this.context);\n    }\n  };\n  PDFObjectParser.prototype.parseDictOrStream = function () {\n    var startPos = this.bytes.position();\n    var dict = this.parseDict();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.streamEOF1) && !this.matchKeyword(Keywords.streamEOF2) && !this.matchKeyword(Keywords.streamEOF3) && !this.matchKeyword(Keywords.streamEOF4) && !this.matchKeyword(Keywords.stream)) {\n      return dict;\n    }\n    var start = this.bytes.offset();\n    var end;\n    var Length = dict.get(PDFName.of('Length'));\n    if (Length instanceof PDFNumber) {\n      end = start + Length.asNumber();\n      this.bytes.moveTo(end);\n      this.skipWhitespaceAndComments();\n      if (!this.matchKeyword(Keywords.endstream)) {\n        this.bytes.moveTo(start);\n        end = this.findEndOfStreamFallback(startPos);\n      }\n    } else {\n      end = this.findEndOfStreamFallback(startPos);\n    }\n    var contents = this.bytes.slice(start, end);\n    return PDFRawStream.of(dict, contents);\n  };\n  PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n    // Move to end of stream, while handling nested streams\n    var nestingLvl = 1;\n    var end = this.bytes.offset();\n    while (!this.bytes.done()) {\n      end = this.bytes.offset();\n      if (this.matchKeyword(Keywords.stream)) {\n        nestingLvl += 1;\n      } else if (this.matchKeyword(Keywords.EOF1endstream) || this.matchKeyword(Keywords.EOF2endstream) || this.matchKeyword(Keywords.EOF3endstream) || this.matchKeyword(Keywords.endstream)) {\n        nestingLvl -= 1;\n      } else {\n        this.bytes.next();\n      }\n      if (nestingLvl === 0) break;\n    }\n    if (nestingLvl !== 0) throw new PDFStreamParsingError(startPos);\n    return end;\n  };\n  PDFObjectParser.forBytes = function (bytes, context, capNumbers) {\n    return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers);\n  };\n  PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    return new PDFObjectParser(byteStream, context, capNumbers);\n  };\n  return PDFObjectParser;\n}(BaseParser);\nexport default PDFObjectParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFObjectParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport { PDFObjectParsingError, PDFStreamParsingError, UnbalancedParenthesisError, } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFBool from \"../objects/PDFBool\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFHexString from \"../objects/PDFHexString\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNull from \"../objects/PDFNull\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFString from \"../objects/PDFString\";\nimport BaseParser from \"./BaseParser\";\nimport ByteStream from \"./ByteStream\";\nimport PDFCatalog from \"../structures/PDFCatalog\";\nimport PDFPageLeaf from \"../structures/PDFPageLeaf\";\nimport PDFPageTree from \"../structures/PDFPageTree\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDelimiter } from \"../syntax/Delimiters\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\n// TODO: Throw error if eof is reached before finishing object parse...\nvar PDFObjectParser = /** @class */ (function (_super) {\n    __extends(PDFObjectParser, _super);\n    function PDFObjectParser(byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, byteStream, capNumbers) || this;\n        _this.context = context;\n        return _this;\n    }\n    // TODO: Is it possible to reduce duplicate parsing for ref lookaheads?\n    PDFObjectParser.prototype.parseObject = function () {\n        this.skipWhitespaceAndComments();\n        if (this.matchKeyword(Keywords.true))\n            return PDFBool.True;\n        if (this.matchKeyword(Keywords.false))\n            return PDFBool.False;\n        if (this.matchKeyword(Keywords.null))\n            return PDFNull;\n        var byte = this.bytes.peek();\n        if (byte === CharCodes.LessThan &&\n            this.bytes.peekAhead(1) === CharCodes.LessThan) {\n            return this.parseDictOrStream();\n        }\n        if (byte === CharCodes.LessThan)\n            return this.parseHexString();\n        if (byte === CharCodes.LeftParen)\n            return this.parseString();\n        if (byte === CharCodes.ForwardSlash)\n            return this.parseName();\n        if (byte === CharCodes.LeftSquareBracket)\n            return this.parseArray();\n        if (IsNumeric[byte])\n            return this.parseNumberOrRef();\n        throw new PDFObjectParsingError(this.bytes.position(), byte);\n    };\n    PDFObjectParser.prototype.parseNumberOrRef = function () {\n        var firstNum = this.parseRawNumber();\n        this.skipWhitespaceAndComments();\n        var lookaheadStart = this.bytes.offset();\n        if (IsDigit[this.bytes.peek()]) {\n            var secondNum = this.parseRawNumber();\n            this.skipWhitespaceAndComments();\n            if (this.bytes.peek() === CharCodes.R) {\n                this.bytes.assertNext(CharCodes.R);\n                return PDFRef.of(firstNum, secondNum);\n            }\n        }\n        this.bytes.moveTo(lookaheadStart);\n        return PDFNumber.of(firstNum);\n    };\n    // TODO: Maybe update PDFHexString.of() logic to remove whitespace and validate input?\n    PDFObjectParser.prototype.parseHexString = function () {\n        var value = '';\n        this.bytes.assertNext(CharCodes.LessThan);\n        while (!this.bytes.done() && this.bytes.peek() !== CharCodes.GreaterThan) {\n            value += charFromCode(this.bytes.next());\n        }\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        return PDFHexString.of(value);\n    };\n    PDFObjectParser.prototype.parseString = function () {\n        var nestingLvl = 0;\n        var isEscaped = false;\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.next();\n            value += charFromCode(byte);\n            // Check for unescaped parenthesis\n            if (!isEscaped) {\n                if (byte === CharCodes.LeftParen)\n                    nestingLvl += 1;\n                if (byte === CharCodes.RightParen)\n                    nestingLvl -= 1;\n            }\n            // Track whether current character is being escaped or not\n            if (byte === CharCodes.BackSlash) {\n                isEscaped = !isEscaped;\n            }\n            else if (isEscaped) {\n                isEscaped = false;\n            }\n            // Once (if) the unescaped parenthesis balance out, return their contents\n            if (nestingLvl === 0) {\n                // Remove the outer parens so they aren't part of the contents\n                return PDFString.of(value.substring(1, value.length - 1));\n            }\n        }\n        throw new UnbalancedParenthesisError(this.bytes.position());\n    };\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    // TODO: Maybe preallocate small Uint8Array if can use charFromCode?\n    PDFObjectParser.prototype.parseName = function () {\n        this.bytes.assertNext(CharCodes.ForwardSlash);\n        var name = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (IsWhitespace[byte] || IsDelimiter[byte])\n                break;\n            name += charFromCode(byte);\n            this.bytes.next();\n        }\n        return PDFName.of(name);\n    };\n    PDFObjectParser.prototype.parseArray = function () {\n        this.bytes.assertNext(CharCodes.LeftSquareBracket);\n        this.skipWhitespaceAndComments();\n        var pdfArray = PDFArray.withContext(this.context);\n        while (this.bytes.peek() !== CharCodes.RightSquareBracket) {\n            var element = this.parseObject();\n            pdfArray.push(element);\n            this.skipWhitespaceAndComments();\n        }\n        this.bytes.assertNext(CharCodes.RightSquareBracket);\n        return pdfArray;\n    };\n    PDFObjectParser.prototype.parseDict = function () {\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.bytes.assertNext(CharCodes.LessThan);\n        this.skipWhitespaceAndComments();\n        var dict = new Map();\n        while (!this.bytes.done() &&\n            this.bytes.peek() !== CharCodes.GreaterThan &&\n            this.bytes.peekAhead(1) !== CharCodes.GreaterThan) {\n            var key = this.parseName();\n            var value = this.parseObject();\n            dict.set(key, value);\n            this.skipWhitespaceAndComments();\n        }\n        this.skipWhitespaceAndComments();\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        this.bytes.assertNext(CharCodes.GreaterThan);\n        var Type = dict.get(PDFName.of('Type'));\n        if (Type === PDFName.of('Catalog')) {\n            return PDFCatalog.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Pages')) {\n            return PDFPageTree.fromMapWithContext(dict, this.context);\n        }\n        else if (Type === PDFName.of('Page')) {\n            return PDFPageLeaf.fromMapWithContext(dict, this.context);\n        }\n        else {\n            return PDFDict.fromMapWithContext(dict, this.context);\n        }\n    };\n    PDFObjectParser.prototype.parseDictOrStream = function () {\n        var startPos = this.bytes.position();\n        var dict = this.parseDict();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.streamEOF1) &&\n            !this.matchKeyword(Keywords.streamEOF2) &&\n            !this.matchKeyword(Keywords.streamEOF3) &&\n            !this.matchKeyword(Keywords.streamEOF4) &&\n            !this.matchKeyword(Keywords.stream)) {\n            return dict;\n        }\n        var start = this.bytes.offset();\n        var end;\n        var Length = dict.get(PDFName.of('Length'));\n        if (Length instanceof PDFNumber) {\n            end = start + Length.asNumber();\n            this.bytes.moveTo(end);\n            this.skipWhitespaceAndComments();\n            if (!this.matchKeyword(Keywords.endstream)) {\n                this.bytes.moveTo(start);\n                end = this.findEndOfStreamFallback(startPos);\n            }\n        }\n        else {\n            end = this.findEndOfStreamFallback(startPos);\n        }\n        var contents = this.bytes.slice(start, end);\n        return PDFRawStream.of(dict, contents);\n    };\n    PDFObjectParser.prototype.findEndOfStreamFallback = function (startPos) {\n        // Move to end of stream, while handling nested streams\n        var nestingLvl = 1;\n        var end = this.bytes.offset();\n        while (!this.bytes.done()) {\n            end = this.bytes.offset();\n            if (this.matchKeyword(Keywords.stream)) {\n                nestingLvl += 1;\n            }\n            else if (this.matchKeyword(Keywords.EOF1endstream) ||\n                this.matchKeyword(Keywords.EOF2endstream) ||\n                this.matchKeyword(Keywords.EOF3endstream) ||\n                this.matchKeyword(Keywords.endstream)) {\n                nestingLvl -= 1;\n            }\n            else {\n                this.bytes.next();\n            }\n            if (nestingLvl === 0)\n                break;\n        }\n        if (nestingLvl !== 0)\n            throw new PDFStreamParsingError(startPos);\n        return end;\n    };\n    PDFObjectParser.forBytes = function (bytes, context, capNumbers) { return new PDFObjectParser(ByteStream.of(bytes), context, capNumbers); };\n    PDFObjectParser.forByteStream = function (byteStream, context, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        return new PDFObjectParser(byteStream, context, capNumbers);\n    };\n    return PDFObjectParser;\n}(BaseParser));\nexport default PDFObjectParser;\n//# sourceMappingURL=PDFObjectParser.js.map"]},"metadata":{},"sourceType":"module"}