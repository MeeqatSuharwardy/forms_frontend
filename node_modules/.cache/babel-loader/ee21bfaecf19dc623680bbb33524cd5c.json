{"ast":null,"code":"/*\n * Copyright 2012 Mozilla Foundation\n *\n * The LZWStream class contained in this file is a TypeScript port of the\n * JavaScript LZWStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar LZWStream = /** @class */function (_super) {\n  __extends(LZWStream, _super);\n  function LZWStream(stream, maybeLength, earlyChange) {\n    var _this = _super.call(this, maybeLength) || this;\n    _this.stream = stream;\n    _this.cachedData = 0;\n    _this.bitsCached = 0;\n    var maxLzwDictionarySize = 4096;\n    var lzwState = {\n      earlyChange: earlyChange,\n      codeLength: 9,\n      nextCode: 258,\n      dictionaryValues: new Uint8Array(maxLzwDictionarySize),\n      dictionaryLengths: new Uint16Array(maxLzwDictionarySize),\n      dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),\n      currentSequence: new Uint8Array(maxLzwDictionarySize),\n      currentSequenceLength: 0\n    };\n    for (var i = 0; i < 256; ++i) {\n      lzwState.dictionaryValues[i] = i;\n      lzwState.dictionaryLengths[i] = 1;\n    }\n    _this.lzwState = lzwState;\n    return _this;\n  }\n  LZWStream.prototype.readBlock = function () {\n    var blockSize = 512;\n    var estimatedDecodedSize = blockSize * 2;\n    var decodedSizeDelta = blockSize;\n    var i;\n    var j;\n    var q;\n    var lzwState = this.lzwState;\n    if (!lzwState) {\n      return; // eof was found\n    }\n    var earlyChange = lzwState.earlyChange;\n    var nextCode = lzwState.nextCode;\n    var dictionaryValues = lzwState.dictionaryValues;\n    var dictionaryLengths = lzwState.dictionaryLengths;\n    var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;\n    var codeLength = lzwState.codeLength;\n    var prevCode = lzwState.prevCode;\n    var currentSequence = lzwState.currentSequence;\n    var currentSequenceLength = lzwState.currentSequenceLength;\n    var decodedLength = 0;\n    var currentBufferLength = this.bufferLength;\n    var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n    for (i = 0; i < blockSize; i++) {\n      var code = this.readBits(codeLength);\n      var hasPrev = currentSequenceLength > 0;\n      if (!code || code < 256) {\n        currentSequence[0] = code;\n        currentSequenceLength = 1;\n      } else if (code >= 258) {\n        if (code < nextCode) {\n          currentSequenceLength = dictionaryLengths[code];\n          for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {\n            currentSequence[j] = dictionaryValues[q];\n            q = dictionaryPrevCodes[q];\n          }\n        } else {\n          currentSequence[currentSequenceLength++] = currentSequence[0];\n        }\n      } else if (code === 256) {\n        codeLength = 9;\n        nextCode = 258;\n        currentSequenceLength = 0;\n        continue;\n      } else {\n        this.eof = true;\n        delete this.lzwState;\n        break;\n      }\n      if (hasPrev) {\n        dictionaryPrevCodes[nextCode] = prevCode;\n        dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;\n        dictionaryValues[nextCode] = currentSequence[0];\n        nextCode++;\n        codeLength = nextCode + earlyChange & nextCode + earlyChange - 1 ? codeLength : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;\n      }\n      prevCode = code;\n      decodedLength += currentSequenceLength;\n      if (estimatedDecodedSize < decodedLength) {\n        do {\n          estimatedDecodedSize += decodedSizeDelta;\n        } while (estimatedDecodedSize < decodedLength);\n        buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n      }\n      for (j = 0; j < currentSequenceLength; j++) {\n        buffer[currentBufferLength++] = currentSequence[j];\n      }\n    }\n    lzwState.nextCode = nextCode;\n    lzwState.codeLength = codeLength;\n    lzwState.prevCode = prevCode;\n    lzwState.currentSequenceLength = currentSequenceLength;\n    this.bufferLength = currentBufferLength;\n  };\n  LZWStream.prototype.readBits = function (n) {\n    var bitsCached = this.bitsCached;\n    var cachedData = this.cachedData;\n    while (bitsCached < n) {\n      var c = this.stream.getByte();\n      if (c === -1) {\n        this.eof = true;\n        return null;\n      }\n      cachedData = cachedData << 8 | c;\n      bitsCached += 8;\n    }\n    this.bitsCached = bitsCached -= n;\n    this.cachedData = cachedData;\n    return cachedData >>> bitsCached & (1 << n) - 1;\n  };\n  return LZWStream;\n}(DecodeStream);\nexport default LZWStream;","map":{"version":3,"sources":["../../../src/core/streams/LZWStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The LZWStream class contained in this file is a TypeScript port of the\n * JavaScript LZWStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar LZWStream = /** @class */ (function (_super) {\n    __extends(LZWStream, _super);\n    function LZWStream(stream, maybeLength, earlyChange) {\n        var _this = _super.call(this, maybeLength) || this;\n        _this.stream = stream;\n        _this.cachedData = 0;\n        _this.bitsCached = 0;\n        var maxLzwDictionarySize = 4096;\n        var lzwState = {\n            earlyChange: earlyChange,\n            codeLength: 9,\n            nextCode: 258,\n            dictionaryValues: new Uint8Array(maxLzwDictionarySize),\n            dictionaryLengths: new Uint16Array(maxLzwDictionarySize),\n            dictionaryPrevCodes: new Uint16Array(maxLzwDictionarySize),\n            currentSequence: new Uint8Array(maxLzwDictionarySize),\n            currentSequenceLength: 0,\n        };\n        for (var i = 0; i < 256; ++i) {\n            lzwState.dictionaryValues[i] = i;\n            lzwState.dictionaryLengths[i] = 1;\n        }\n        _this.lzwState = lzwState;\n        return _this;\n    }\n    LZWStream.prototype.readBlock = function () {\n        var blockSize = 512;\n        var estimatedDecodedSize = blockSize * 2;\n        var decodedSizeDelta = blockSize;\n        var i;\n        var j;\n        var q;\n        var lzwState = this.lzwState;\n        if (!lzwState) {\n            return; // eof was found\n        }\n        var earlyChange = lzwState.earlyChange;\n        var nextCode = lzwState.nextCode;\n        var dictionaryValues = lzwState.dictionaryValues;\n        var dictionaryLengths = lzwState.dictionaryLengths;\n        var dictionaryPrevCodes = lzwState.dictionaryPrevCodes;\n        var codeLength = lzwState.codeLength;\n        var prevCode = lzwState.prevCode;\n        var currentSequence = lzwState.currentSequence;\n        var currentSequenceLength = lzwState.currentSequenceLength;\n        var decodedLength = 0;\n        var currentBufferLength = this.bufferLength;\n        var buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n        for (i = 0; i < blockSize; i++) {\n            var code = this.readBits(codeLength);\n            var hasPrev = currentSequenceLength > 0;\n            if (!code || code < 256) {\n                currentSequence[0] = code;\n                currentSequenceLength = 1;\n            }\n            else if (code >= 258) {\n                if (code < nextCode) {\n                    currentSequenceLength = dictionaryLengths[code];\n                    for (j = currentSequenceLength - 1, q = code; j >= 0; j--) {\n                        currentSequence[j] = dictionaryValues[q];\n                        q = dictionaryPrevCodes[q];\n                    }\n                }\n                else {\n                    currentSequence[currentSequenceLength++] = currentSequence[0];\n                }\n            }\n            else if (code === 256) {\n                codeLength = 9;\n                nextCode = 258;\n                currentSequenceLength = 0;\n                continue;\n            }\n            else {\n                this.eof = true;\n                delete this.lzwState;\n                break;\n            }\n            if (hasPrev) {\n                dictionaryPrevCodes[nextCode] = prevCode;\n                dictionaryLengths[nextCode] = dictionaryLengths[prevCode] + 1;\n                dictionaryValues[nextCode] = currentSequence[0];\n                nextCode++;\n                codeLength =\n                    (nextCode + earlyChange) & (nextCode + earlyChange - 1)\n                        ? codeLength\n                        : Math.min(Math.log(nextCode + earlyChange) / 0.6931471805599453 + 1, 12) | 0;\n            }\n            prevCode = code;\n            decodedLength += currentSequenceLength;\n            if (estimatedDecodedSize < decodedLength) {\n                do {\n                    estimatedDecodedSize += decodedSizeDelta;\n                } while (estimatedDecodedSize < decodedLength);\n                buffer = this.ensureBuffer(this.bufferLength + estimatedDecodedSize);\n            }\n            for (j = 0; j < currentSequenceLength; j++) {\n                buffer[currentBufferLength++] = currentSequence[j];\n            }\n        }\n        lzwState.nextCode = nextCode;\n        lzwState.codeLength = codeLength;\n        lzwState.prevCode = prevCode;\n        lzwState.currentSequenceLength = currentSequenceLength;\n        this.bufferLength = currentBufferLength;\n    };\n    LZWStream.prototype.readBits = function (n) {\n        var bitsCached = this.bitsCached;\n        var cachedData = this.cachedData;\n        while (bitsCached < n) {\n            var c = this.stream.getByte();\n            if (c === -1) {\n                this.eof = true;\n                return null;\n            }\n            cachedData = (cachedData << 8) | c;\n            bitsCached += 8;\n        }\n        this.bitsCached = bitsCached -= n;\n        this.cachedData = cachedData;\n        return (cachedData >>> bitsCached) & ((1 << n) - 1);\n    };\n    return LZWStream;\n}(DecodeStream));\nexport default LZWStream;\n//# sourceMappingURL=LZWStream.js.map"]},"metadata":{},"sourceType":"module"}