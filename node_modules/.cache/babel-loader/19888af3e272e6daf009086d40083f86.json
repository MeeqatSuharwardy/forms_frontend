{"ast":null,"code":"/*\n * The `chars`, `lookup`, `encode`, and `decode` members of this file are\n * licensed under the following:\n *\n *     base64-arraybuffer\n *     https://github.com/niklasvh/base64-arraybuffer\n *\n *     Copyright (c) 2012 Niklas von Hertzen\n *     Licensed under the MIT license.\n *\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n  lookup[chars.charCodeAt(i)] = i;\n}\nexport var encodeToBase64 = function (bytes) {\n  var base64 = '';\n  var len = bytes.length;\n  for (var i = 0; i < len; i += 3) {\n    base64 += chars[bytes[i] >> 2];\n    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += chars[bytes[i + 2] & 63];\n  }\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n  return base64;\n};\nexport var decodeFromBase64 = function (base64) {\n  var bufferLength = base64.length * 0.75;\n  var len = base64.length;\n  var i;\n  var p = 0;\n  var encoded1;\n  var encoded2;\n  var encoded3;\n  var encoded4;\n  if (base64[base64.length - 1] === '=') {\n    bufferLength--;\n    if (base64[base64.length - 2] === '=') {\n      bufferLength--;\n    }\n  }\n  var bytes = new Uint8Array(bufferLength);\n  for (i = 0; i < len; i += 4) {\n    encoded1 = lookup[base64.charCodeAt(i)];\n    encoded2 = lookup[base64.charCodeAt(i + 1)];\n    encoded3 = lookup[base64.charCodeAt(i + 2)];\n    encoded4 = lookup[base64.charCodeAt(i + 3)];\n    bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n  }\n  return bytes;\n};\n// This regex is designed to be as flexible as possible. It will parse certain\n// invalid data URIs.\nvar DATA_URI_PREFIX_REGEX = /^(data)?:?([\\w\\/\\+]+)?;?(charset=[\\w-]+|base64)?.*,/i;\n/**\n * If the `dataUri` input is a data URI, then the data URI prefix must not be\n * longer than 100 characters, or this function will fail to decode it.\n *\n * @param dataUri a base64 data URI or plain base64 string\n * @returns a Uint8Array containing the decoded input\n */\nexport var decodeFromBase64DataUri = function (dataUri) {\n  var trimmedUri = dataUri.trim();\n  var prefix = trimmedUri.substring(0, 100);\n  var res = prefix.match(DATA_URI_PREFIX_REGEX);\n  // Assume it's not a data URI - just a plain base64 string\n  if (!res) return decodeFromBase64(trimmedUri);\n  // Remove the data URI prefix and parse the remainder as a base64 string\n  var fullMatch = res[0];\n  var data = trimmedUri.substring(fullMatch.length);\n  return decodeFromBase64(data);\n};","map":{"version":3,"sources":["../../src/utils/base64.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * The `chars`, `lookup`, `encode`, and `decode` members of this file are\n * licensed under the following:\n *\n *     base64-arraybuffer\n *     https://github.com/niklasvh/base64-arraybuffer\n *\n *     Copyright (c) 2012 Niklas von Hertzen\n *     Licensed under the MIT license.\n *\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nexport var encodeToBase64 = function (bytes) {\n    var base64 = '';\n    var len = bytes.length;\n    for (var i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexport var decodeFromBase64 = function (base64) {\n    var bufferLength = base64.length * 0.75;\n    var len = base64.length;\n    var i;\n    var p = 0;\n    var encoded1;\n    var encoded2;\n    var encoded3;\n    var encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    var bytes = new Uint8Array(bufferLength);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return bytes;\n};\n// This regex is designed to be as flexible as possible. It will parse certain\n// invalid data URIs.\nvar DATA_URI_PREFIX_REGEX = /^(data)?:?([\\w\\/\\+]+)?;?(charset=[\\w-]+|base64)?.*,/i;\n/**\n * If the `dataUri` input is a data URI, then the data URI prefix must not be\n * longer than 100 characters, or this function will fail to decode it.\n *\n * @param dataUri a base64 data URI or plain base64 string\n * @returns a Uint8Array containing the decoded input\n */\nexport var decodeFromBase64DataUri = function (dataUri) {\n    var trimmedUri = dataUri.trim();\n    var prefix = trimmedUri.substring(0, 100);\n    var res = prefix.match(DATA_URI_PREFIX_REGEX);\n    // Assume it's not a data URI - just a plain base64 string\n    if (!res)\n        return decodeFromBase64(trimmedUri);\n    // Remove the data URI prefix and parse the remainder as a base64 string\n    var fullMatch = res[0];\n    var data = trimmedUri.substring(fullMatch.length);\n    return decodeFromBase64(data);\n};\n//# sourceMappingURL=base64.js.map"]},"metadata":{},"sourceType":"module"}