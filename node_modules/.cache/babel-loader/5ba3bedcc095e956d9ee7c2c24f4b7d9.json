{"ast":null,"code":"import { __extends, __spreadArrays } from \"tslib\";\nimport PDFName from \"./PDFName\";\nimport PDFNull from \"./PDFNull\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nvar PDFDict = /** @class */function (_super) {\n  __extends(PDFDict, _super);\n  function PDFDict(map, context) {\n    var _this = _super.call(this) || this;\n    _this.dict = map;\n    _this.context = context;\n    return _this;\n  }\n  PDFDict.prototype.keys = function () {\n    return Array.from(this.dict.keys());\n  };\n  PDFDict.prototype.values = function () {\n    return Array.from(this.dict.values());\n  };\n  PDFDict.prototype.entries = function () {\n    return Array.from(this.dict.entries());\n  };\n  PDFDict.prototype.set = function (key, value) {\n    this.dict.set(key, value);\n  };\n  PDFDict.prototype.get = function (key,\n  // TODO: `preservePDFNull` is for backwards compatibility. Should be\n  // removed in next breaking API change.\n  preservePDFNull) {\n    if (preservePDFNull === void 0) {\n      preservePDFNull = false;\n    }\n    var value = this.dict.get(key);\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.has = function (key) {\n    var value = this.dict.get(key);\n    return value !== undefined && value !== PDFNull;\n  };\n  PDFDict.prototype.lookupMaybe = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull);\n    var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.lookup = function (key) {\n    var _a;\n    var types = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      types[_i - 1] = arguments[_i];\n    }\n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    var preservePDFNull = types.includes(PDFNull);\n    var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n    if (value === PDFNull && !preservePDFNull) return undefined;\n    return value;\n  };\n  PDFDict.prototype.delete = function (key) {\n    return this.dict.delete(key);\n  };\n  PDFDict.prototype.asMap = function () {\n    return new Map(this.dict);\n  };\n  /** Generate a random key that doesn't exist in current key set */\n  PDFDict.prototype.uniqueKey = function (tag) {\n    if (tag === void 0) {\n      tag = '';\n    }\n    var existingKeys = this.keys();\n    var key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    while (existingKeys.includes(key)) {\n      key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n    }\n    return key;\n  };\n  PDFDict.prototype.clone = function (context) {\n    var clone = PDFDict.withContext(context || this.context);\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      clone.set(key, value);\n    }\n    return clone;\n  };\n  PDFDict.prototype.toString = function () {\n    var dictString = '<<\\n';\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      dictString += key.toString() + ' ' + value.toString() + '\\n';\n    }\n    dictString += '>>';\n    return dictString;\n  };\n  PDFDict.prototype.sizeInBytes = function () {\n    var size = 5;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      size += key.sizeInBytes() + value.sizeInBytes() + 2;\n    }\n    return size;\n  };\n  PDFDict.prototype.copyBytesInto = function (buffer, offset) {\n    var initialOffset = offset;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.LessThan;\n    buffer[offset++] = CharCodes.Newline;\n    var entries = this.entries();\n    for (var idx = 0, len = entries.length; idx < len; idx++) {\n      var _a = entries[idx],\n        key = _a[0],\n        value = _a[1];\n      offset += key.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Space;\n      offset += value.copyBytesInto(buffer, offset);\n      buffer[offset++] = CharCodes.Newline;\n    }\n    buffer[offset++] = CharCodes.GreaterThan;\n    buffer[offset++] = CharCodes.GreaterThan;\n    return offset - initialOffset;\n  };\n  PDFDict.withContext = function (context) {\n    return new PDFDict(new Map(), context);\n  };\n  PDFDict.fromMapWithContext = function (map, context) {\n    return new PDFDict(map, context);\n  };\n  return PDFDict;\n}(PDFObject);\nexport default PDFDict;","map":{"version":3,"sources":["../../../src/core/objects/PDFDict.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends, __spreadArrays } from \"tslib\";\nimport PDFName from \"./PDFName\";\nimport PDFNull from \"./PDFNull\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nvar PDFDict = /** @class */ (function (_super) {\n    __extends(PDFDict, _super);\n    function PDFDict(map, context) {\n        var _this = _super.call(this) || this;\n        _this.dict = map;\n        _this.context = context;\n        return _this;\n    }\n    PDFDict.prototype.keys = function () {\n        return Array.from(this.dict.keys());\n    };\n    PDFDict.prototype.values = function () {\n        return Array.from(this.dict.values());\n    };\n    PDFDict.prototype.entries = function () {\n        return Array.from(this.dict.entries());\n    };\n    PDFDict.prototype.set = function (key, value) {\n        this.dict.set(key, value);\n    };\n    PDFDict.prototype.get = function (key, \n    // TODO: `preservePDFNull` is for backwards compatibility. Should be\n    // removed in next breaking API change.\n    preservePDFNull) {\n        if (preservePDFNull === void 0) { preservePDFNull = false; }\n        var value = this.dict.get(key);\n        if (value === PDFNull && !preservePDFNull)\n            return undefined;\n        return value;\n    };\n    PDFDict.prototype.has = function (key) {\n        var value = this.dict.get(key);\n        return value !== undefined && value !== PDFNull;\n    };\n    PDFDict.prototype.lookupMaybe = function (key) {\n        var _a;\n        var types = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            types[_i - 1] = arguments[_i];\n        }\n        // TODO: `preservePDFNull` is for backwards compatibility. Should be\n        // removed in next breaking API change.\n        var preservePDFNull = types.includes(PDFNull);\n        var value = (_a = this.context).lookupMaybe.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n        if (value === PDFNull && !preservePDFNull)\n            return undefined;\n        return value;\n    };\n    PDFDict.prototype.lookup = function (key) {\n        var _a;\n        var types = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            types[_i - 1] = arguments[_i];\n        }\n        // TODO: `preservePDFNull` is for backwards compatibility. Should be\n        // removed in next breaking API change.\n        var preservePDFNull = types.includes(PDFNull);\n        var value = (_a = this.context).lookup.apply(_a, __spreadArrays([this.get(key, preservePDFNull)], types));\n        if (value === PDFNull && !preservePDFNull)\n            return undefined;\n        return value;\n    };\n    PDFDict.prototype.delete = function (key) {\n        return this.dict.delete(key);\n    };\n    PDFDict.prototype.asMap = function () {\n        return new Map(this.dict);\n    };\n    /** Generate a random key that doesn't exist in current key set */\n    PDFDict.prototype.uniqueKey = function (tag) {\n        if (tag === void 0) { tag = ''; }\n        var existingKeys = this.keys();\n        var key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n        while (existingKeys.includes(key)) {\n            key = PDFName.of(this.context.addRandomSuffix(tag, 10));\n        }\n        return key;\n    };\n    PDFDict.prototype.clone = function (context) {\n        var clone = PDFDict.withContext(context || this.context);\n        var entries = this.entries();\n        for (var idx = 0, len = entries.length; idx < len; idx++) {\n            var _a = entries[idx], key = _a[0], value = _a[1];\n            clone.set(key, value);\n        }\n        return clone;\n    };\n    PDFDict.prototype.toString = function () {\n        var dictString = '<<\\n';\n        var entries = this.entries();\n        for (var idx = 0, len = entries.length; idx < len; idx++) {\n            var _a = entries[idx], key = _a[0], value = _a[1];\n            dictString += key.toString() + ' ' + value.toString() + '\\n';\n        }\n        dictString += '>>';\n        return dictString;\n    };\n    PDFDict.prototype.sizeInBytes = function () {\n        var size = 5;\n        var entries = this.entries();\n        for (var idx = 0, len = entries.length; idx < len; idx++) {\n            var _a = entries[idx], key = _a[0], value = _a[1];\n            size += key.sizeInBytes() + value.sizeInBytes() + 2;\n        }\n        return size;\n    };\n    PDFDict.prototype.copyBytesInto = function (buffer, offset) {\n        var initialOffset = offset;\n        buffer[offset++] = CharCodes.LessThan;\n        buffer[offset++] = CharCodes.LessThan;\n        buffer[offset++] = CharCodes.Newline;\n        var entries = this.entries();\n        for (var idx = 0, len = entries.length; idx < len; idx++) {\n            var _a = entries[idx], key = _a[0], value = _a[1];\n            offset += key.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            offset += value.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n        }\n        buffer[offset++] = CharCodes.GreaterThan;\n        buffer[offset++] = CharCodes.GreaterThan;\n        return offset - initialOffset;\n    };\n    PDFDict.withContext = function (context) { return new PDFDict(new Map(), context); };\n    PDFDict.fromMapWithContext = function (map, context) {\n        return new PDFDict(map, context);\n    };\n    return PDFDict;\n}(PDFObject));\nexport default PDFDict;\n//# sourceMappingURL=PDFDict.js.map"]},"metadata":{},"sourceType":"module"}