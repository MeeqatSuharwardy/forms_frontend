{"ast":null,"code":"import { ReparseError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nvar PDFXRefStreamParser = /** @class */function () {\n  function PDFXRefStreamParser(rawStream) {\n    this.alreadyParsed = false;\n    this.dict = rawStream.dict;\n    this.bytes = ByteStream.fromPDFRawStream(rawStream);\n    this.context = this.dict.context;\n    var Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\n    var Index = this.dict.lookup(PDFName.of('Index'));\n    if (Index instanceof PDFArray) {\n      this.subsections = [];\n      for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\n        var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\n        var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();\n        this.subsections.push({\n          firstObjectNumber: firstObjectNumber,\n          length: length_1\n        });\n      }\n    } else {\n      this.subsections = [{\n        firstObjectNumber: 0,\n        length: Size.asNumber()\n      }];\n    }\n    var W = this.dict.lookup(PDFName.of('W'), PDFArray);\n    this.byteWidths = [-1, -1, -1];\n    for (var idx = 0, len = W.size(); idx < len; idx++) {\n      this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\n    }\n  }\n  PDFXRefStreamParser.prototype.parseIntoContext = function () {\n    if (this.alreadyParsed) {\n      throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n    }\n    this.alreadyParsed = true;\n    this.context.trailerInfo = {\n      Root: this.dict.get(PDFName.of('Root')),\n      Encrypt: this.dict.get(PDFName.of('Encrypt')),\n      Info: this.dict.get(PDFName.of('Info')),\n      ID: this.dict.get(PDFName.of('ID'))\n    };\n    var entries = this.parseEntries();\n    // for (let idx = 0, len = entries.length; idx < len; idx++) {\n    // const entry = entries[idx];\n    // if (entry.deleted) this.context.delete(entry.ref);\n    // }\n    return entries;\n  };\n  PDFXRefStreamParser.prototype.parseEntries = function () {\n    var entries = [];\n    var _a = this.byteWidths,\n      typeFieldWidth = _a[0],\n      offsetFieldWidth = _a[1],\n      genFieldWidth = _a[2];\n    for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\n      var _b = this.subsections[subsectionIdx],\n        firstObjectNumber = _b.firstObjectNumber,\n        length_2 = _b.length;\n      for (var objIdx = 0; objIdx < length_2; objIdx++) {\n        var type = 0;\n        for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\n          type = type << 8 | this.bytes.next();\n        }\n        var offset = 0;\n        for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n          offset = offset << 8 | this.bytes.next();\n        }\n        var generationNumber = 0;\n        for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\n          generationNumber = generationNumber << 8 | this.bytes.next();\n        }\n        // When the `type` field is absent, it defaults to 1\n        if (typeFieldWidth === 0) type = 1;\n        var objectNumber = firstObjectNumber + objIdx;\n        var entry = {\n          ref: PDFRef.of(objectNumber, generationNumber),\n          offset: offset,\n          deleted: type === 0,\n          inObjectStream: type === 2\n        };\n        entries.push(entry);\n      }\n    }\n    return entries;\n  };\n  PDFXRefStreamParser.forStream = function (rawStream) {\n    return new PDFXRefStreamParser(rawStream);\n  };\n  return PDFXRefStreamParser;\n}();\nexport default PDFXRefStreamParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFXRefStreamParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ReparseError } from \"../errors\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nvar PDFXRefStreamParser = /** @class */ (function () {\n    function PDFXRefStreamParser(rawStream) {\n        this.alreadyParsed = false;\n        this.dict = rawStream.dict;\n        this.bytes = ByteStream.fromPDFRawStream(rawStream);\n        this.context = this.dict.context;\n        var Size = this.dict.lookup(PDFName.of('Size'), PDFNumber);\n        var Index = this.dict.lookup(PDFName.of('Index'));\n        if (Index instanceof PDFArray) {\n            this.subsections = [];\n            for (var idx = 0, len = Index.size(); idx < len; idx += 2) {\n                var firstObjectNumber = Index.lookup(idx + 0, PDFNumber).asNumber();\n                var length_1 = Index.lookup(idx + 1, PDFNumber).asNumber();\n                this.subsections.push({ firstObjectNumber: firstObjectNumber, length: length_1 });\n            }\n        }\n        else {\n            this.subsections = [{ firstObjectNumber: 0, length: Size.asNumber() }];\n        }\n        var W = this.dict.lookup(PDFName.of('W'), PDFArray);\n        this.byteWidths = [-1, -1, -1];\n        for (var idx = 0, len = W.size(); idx < len; idx++) {\n            this.byteWidths[idx] = W.lookup(idx, PDFNumber).asNumber();\n        }\n    }\n    PDFXRefStreamParser.prototype.parseIntoContext = function () {\n        if (this.alreadyParsed) {\n            throw new ReparseError('PDFXRefStreamParser', 'parseIntoContext');\n        }\n        this.alreadyParsed = true;\n        this.context.trailerInfo = {\n            Root: this.dict.get(PDFName.of('Root')),\n            Encrypt: this.dict.get(PDFName.of('Encrypt')),\n            Info: this.dict.get(PDFName.of('Info')),\n            ID: this.dict.get(PDFName.of('ID')),\n        };\n        var entries = this.parseEntries();\n        // for (let idx = 0, len = entries.length; idx < len; idx++) {\n        // const entry = entries[idx];\n        // if (entry.deleted) this.context.delete(entry.ref);\n        // }\n        return entries;\n    };\n    PDFXRefStreamParser.prototype.parseEntries = function () {\n        var entries = [];\n        var _a = this.byteWidths, typeFieldWidth = _a[0], offsetFieldWidth = _a[1], genFieldWidth = _a[2];\n        for (var subsectionIdx = 0, subsectionLen = this.subsections.length; subsectionIdx < subsectionLen; subsectionIdx++) {\n            var _b = this.subsections[subsectionIdx], firstObjectNumber = _b.firstObjectNumber, length_2 = _b.length;\n            for (var objIdx = 0; objIdx < length_2; objIdx++) {\n                var type = 0;\n                for (var idx = 0, len = typeFieldWidth; idx < len; idx++) {\n                    type = (type << 8) | this.bytes.next();\n                }\n                var offset = 0;\n                for (var idx = 0, len = offsetFieldWidth; idx < len; idx++) {\n                    offset = (offset << 8) | this.bytes.next();\n                }\n                var generationNumber = 0;\n                for (var idx = 0, len = genFieldWidth; idx < len; idx++) {\n                    generationNumber = (generationNumber << 8) | this.bytes.next();\n                }\n                // When the `type` field is absent, it defaults to 1\n                if (typeFieldWidth === 0)\n                    type = 1;\n                var objectNumber = firstObjectNumber + objIdx;\n                var entry = {\n                    ref: PDFRef.of(objectNumber, generationNumber),\n                    offset: offset,\n                    deleted: type === 0,\n                    inObjectStream: type === 2,\n                };\n                entries.push(entry);\n            }\n        }\n        return entries;\n    };\n    PDFXRefStreamParser.forStream = function (rawStream) {\n        return new PDFXRefStreamParser(rawStream);\n    };\n    return PDFXRefStreamParser;\n}());\nexport default PDFXRefStreamParser;\n//# sourceMappingURL=PDFXRefStreamParser.js.map"]},"metadata":{},"sourceType":"module"}