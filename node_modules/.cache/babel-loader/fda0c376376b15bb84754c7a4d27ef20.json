{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, padStart, utf16Decode, pdfDocEncodingDecode, toCharCode, parseDate, hasUtf16BOM } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\nvar PDFString = /** @class */function (_super) {\n  __extends(PDFString, _super);\n  function PDFString(value) {\n    var _this = _super.call(this) || this;\n    _this.value = value;\n    return _this;\n  }\n  PDFString.prototype.asBytes = function () {\n    var bytes = [];\n    var octal = '';\n    var escaped = false;\n    var pushByte = function (byte) {\n      if (byte !== undefined) bytes.push(byte);\n      escaped = false;\n    };\n    for (var idx = 0, len = this.value.length; idx < len; idx++) {\n      var char = this.value[idx];\n      var byte = toCharCode(char);\n      var nextChar = this.value[idx + 1];\n      if (!escaped) {\n        if (byte === CharCodes.BackSlash) escaped = true;else pushByte(byte);\n      } else {\n        if (byte === CharCodes.Newline) pushByte();else if (byte === CharCodes.CarriageReturn) pushByte();else if (byte === CharCodes.n) pushByte(CharCodes.Newline);else if (byte === CharCodes.r) pushByte(CharCodes.CarriageReturn);else if (byte === CharCodes.t) pushByte(CharCodes.Tab);else if (byte === CharCodes.b) pushByte(CharCodes.Backspace);else if (byte === CharCodes.f) pushByte(CharCodes.FormFeed);else if (byte === CharCodes.LeftParen) pushByte(CharCodes.LeftParen);else if (byte === CharCodes.RightParen) pushByte(CharCodes.RightParen);else if (byte === CharCodes.Backspace) pushByte(CharCodes.BackSlash);else if (byte >= CharCodes.Zero && byte <= CharCodes.Seven) {\n          octal += char;\n          if (octal.length === 3 || !(nextChar >= '0' && nextChar <= '7')) {\n            pushByte(parseInt(octal, 8));\n            octal = '';\n          }\n        } else {\n          pushByte(byte);\n        }\n      }\n    }\n    return new Uint8Array(bytes);\n  };\n  PDFString.prototype.decodeText = function () {\n    var bytes = this.asBytes();\n    if (hasUtf16BOM(bytes)) return utf16Decode(bytes);\n    return pdfDocEncodingDecode(bytes);\n  };\n  PDFString.prototype.decodeDate = function () {\n    var text = this.decodeText();\n    var date = parseDate(text);\n    if (!date) throw new InvalidPDFDateStringError(text);\n    return date;\n  };\n  PDFString.prototype.asString = function () {\n    return this.value;\n  };\n  PDFString.prototype.clone = function () {\n    return PDFString.of(this.value);\n  };\n  PDFString.prototype.toString = function () {\n    return \"(\" + this.value + \")\";\n  };\n  PDFString.prototype.sizeInBytes = function () {\n    return this.value.length + 2;\n  };\n  PDFString.prototype.copyBytesInto = function (buffer, offset) {\n    buffer[offset++] = CharCodes.LeftParen;\n    offset += copyStringIntoBuffer(this.value, buffer, offset);\n    buffer[offset++] = CharCodes.RightParen;\n    return this.value.length + 2;\n  };\n  // The PDF spec allows newlines and parens to appear directly within a literal\n  // string. These character _may_ be escaped. But they do not _have_ to be. So\n  // for simplicity, we will not bother escaping them.\n  PDFString.of = function (value) {\n    return new PDFString(value);\n  };\n  PDFString.fromDate = function (date) {\n    var year = padStart(String(date.getUTCFullYear()), 4, '0');\n    var month = padStart(String(date.getUTCMonth() + 1), 2, '0');\n    var day = padStart(String(date.getUTCDate()), 2, '0');\n    var hours = padStart(String(date.getUTCHours()), 2, '0');\n    var mins = padStart(String(date.getUTCMinutes()), 2, '0');\n    var secs = padStart(String(date.getUTCSeconds()), 2, '0');\n    return new PDFString(\"D:\" + year + month + day + hours + mins + secs + \"Z\");\n  };\n  return PDFString;\n}(PDFObject);\nexport default PDFString;","map":{"version":3,"sources":["../../../src/core/objects/PDFString.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFObject from \"./PDFObject\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, padStart, utf16Decode, pdfDocEncodingDecode, toCharCode, parseDate, hasUtf16BOM, } from \"../../utils\";\nimport { InvalidPDFDateStringError } from \"../errors\";\nvar PDFString = /** @class */ (function (_super) {\n    __extends(PDFString, _super);\n    function PDFString(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        return _this;\n    }\n    PDFString.prototype.asBytes = function () {\n        var bytes = [];\n        var octal = '';\n        var escaped = false;\n        var pushByte = function (byte) {\n            if (byte !== undefined)\n                bytes.push(byte);\n            escaped = false;\n        };\n        for (var idx = 0, len = this.value.length; idx < len; idx++) {\n            var char = this.value[idx];\n            var byte = toCharCode(char);\n            var nextChar = this.value[idx + 1];\n            if (!escaped) {\n                if (byte === CharCodes.BackSlash)\n                    escaped = true;\n                else\n                    pushByte(byte);\n            }\n            else {\n                if (byte === CharCodes.Newline)\n                    pushByte();\n                else if (byte === CharCodes.CarriageReturn)\n                    pushByte();\n                else if (byte === CharCodes.n)\n                    pushByte(CharCodes.Newline);\n                else if (byte === CharCodes.r)\n                    pushByte(CharCodes.CarriageReturn);\n                else if (byte === CharCodes.t)\n                    pushByte(CharCodes.Tab);\n                else if (byte === CharCodes.b)\n                    pushByte(CharCodes.Backspace);\n                else if (byte === CharCodes.f)\n                    pushByte(CharCodes.FormFeed);\n                else if (byte === CharCodes.LeftParen)\n                    pushByte(CharCodes.LeftParen);\n                else if (byte === CharCodes.RightParen)\n                    pushByte(CharCodes.RightParen);\n                else if (byte === CharCodes.Backspace)\n                    pushByte(CharCodes.BackSlash);\n                else if (byte >= CharCodes.Zero && byte <= CharCodes.Seven) {\n                    octal += char;\n                    if (octal.length === 3 || !(nextChar >= '0' && nextChar <= '7')) {\n                        pushByte(parseInt(octal, 8));\n                        octal = '';\n                    }\n                }\n                else {\n                    pushByte(byte);\n                }\n            }\n        }\n        return new Uint8Array(bytes);\n    };\n    PDFString.prototype.decodeText = function () {\n        var bytes = this.asBytes();\n        if (hasUtf16BOM(bytes))\n            return utf16Decode(bytes);\n        return pdfDocEncodingDecode(bytes);\n    };\n    PDFString.prototype.decodeDate = function () {\n        var text = this.decodeText();\n        var date = parseDate(text);\n        if (!date)\n            throw new InvalidPDFDateStringError(text);\n        return date;\n    };\n    PDFString.prototype.asString = function () {\n        return this.value;\n    };\n    PDFString.prototype.clone = function () {\n        return PDFString.of(this.value);\n    };\n    PDFString.prototype.toString = function () {\n        return \"(\" + this.value + \")\";\n    };\n    PDFString.prototype.sizeInBytes = function () {\n        return this.value.length + 2;\n    };\n    PDFString.prototype.copyBytesInto = function (buffer, offset) {\n        buffer[offset++] = CharCodes.LeftParen;\n        offset += copyStringIntoBuffer(this.value, buffer, offset);\n        buffer[offset++] = CharCodes.RightParen;\n        return this.value.length + 2;\n    };\n    // The PDF spec allows newlines and parens to appear directly within a literal\n    // string. These character _may_ be escaped. But they do not _have_ to be. So\n    // for simplicity, we will not bother escaping them.\n    PDFString.of = function (value) { return new PDFString(value); };\n    PDFString.fromDate = function (date) {\n        var year = padStart(String(date.getUTCFullYear()), 4, '0');\n        var month = padStart(String(date.getUTCMonth() + 1), 2, '0');\n        var day = padStart(String(date.getUTCDate()), 2, '0');\n        var hours = padStart(String(date.getUTCHours()), 2, '0');\n        var mins = padStart(String(date.getUTCMinutes()), 2, '0');\n        var secs = padStart(String(date.getUTCSeconds()), 2, '0');\n        return new PDFString(\"D:\" + year + month + day + hours + mins + secs + \"Z\");\n    };\n    return PDFString;\n}(PDFObject));\nexport default PDFString;\n//# sourceMappingURL=PDFString.js.map"]},"metadata":{},"sourceType":"module"}