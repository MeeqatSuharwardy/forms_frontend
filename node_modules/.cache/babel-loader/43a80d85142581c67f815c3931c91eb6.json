{"ast":null,"code":"/* tslint:disable:ban-types */\nimport { values as objectValues } from \"./objects\";\nexport var backtick = function (val) {\n  return \"`\" + val + \"`\";\n};\nexport var singleQuote = function (val) {\n  return \"'\" + val + \"'\";\n};\n// prettier-ignore\nvar formatValue = function (value) {\n  var type = typeof value;\n  if (type === 'string') return singleQuote(value);else if (type === 'undefined') return backtick(value);else return value;\n};\nexport var createValueErrorMsg = function (value, valueName, values) {\n  var allowedValues = new Array(values.length);\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    var v = values[idx];\n    allowedValues[idx] = formatValue(v);\n  }\n  var joinedValues = allowedValues.join(' or ');\n  // prettier-ignore\n  return backtick(valueName) + \" must be one of \" + joinedValues + \", but was actually \" + formatValue(value);\n};\nexport var assertIsOneOf = function (value, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (var idx = 0, len = allowedValues.length; idx < len; idx++) {\n    if (value === allowedValues[idx]) return;\n  }\n  throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));\n};\nexport var assertIsOneOfOrUndefined = function (value, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  assertIsOneOf(value, valueName, allowedValues.concat(undefined));\n};\nexport var assertIsSubset = function (values, valueName, allowedValues) {\n  if (!Array.isArray(allowedValues)) {\n    allowedValues = objectValues(allowedValues);\n  }\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    assertIsOneOf(values[idx], valueName, allowedValues);\n  }\n};\nexport var getType = function (val) {\n  if (val === null) return 'null';\n  if (val === undefined) return 'undefined';\n  if (typeof val === 'string') return 'string';\n  if (isNaN(val)) return 'NaN';\n  if (typeof val === 'number') return 'number';\n  if (typeof val === 'boolean') return 'boolean';\n  if (typeof val === 'symbol') return 'symbol';\n  if (typeof val === 'bigint') return 'bigint';\n  if (val.constructor && val.constructor.name) return val.constructor.name;\n  if (val.name) return val.name;\n  if (val.constructor) return String(val.constructor);\n  return String(val);\n};\nexport var isType = function (value, type) {\n  if (type === 'null') return value === null;\n  if (type === 'undefined') return value === undefined;\n  if (type === 'string') return typeof value === 'string';\n  if (type === 'number') return typeof value === 'number' && !isNaN(value);\n  if (type === 'boolean') return typeof value === 'boolean';\n  if (type === 'symbol') return typeof value === 'symbol';\n  if (type === 'bigint') return typeof value === 'bigint';\n  if (type === Date) return value instanceof Date;\n  if (type === Array) return value instanceof Array;\n  if (type === Uint8Array) return value instanceof Uint8Array;\n  if (type === ArrayBuffer) return value instanceof ArrayBuffer;\n  if (type === Function) return value instanceof Function;\n  return value instanceof type[0];\n};\nexport var createTypeErrorMsg = function (value, valueName, types) {\n  var allowedTypes = new Array(types.length);\n  for (var idx = 0, len = types.length; idx < len; idx++) {\n    var type = types[idx];\n    if (type === 'null') allowedTypes[idx] = backtick('null');\n    if (type === 'undefined') allowedTypes[idx] = backtick('undefined');\n    if (type === 'string') allowedTypes[idx] = backtick('string');else if (type === 'number') allowedTypes[idx] = backtick('number');else if (type === 'boolean') allowedTypes[idx] = backtick('boolean');else if (type === 'symbol') allowedTypes[idx] = backtick('symbol');else if (type === 'bigint') allowedTypes[idx] = backtick('bigint');else if (type === Array) allowedTypes[idx] = backtick('Array');else if (type === Uint8Array) allowedTypes[idx] = backtick('Uint8Array');else if (type === ArrayBuffer) allowedTypes[idx] = backtick('ArrayBuffer');else allowedTypes[idx] = backtick(type[1]);\n  }\n  var joinedTypes = allowedTypes.join(' or ');\n  // prettier-ignore\n  return backtick(valueName) + \" must be of type \" + joinedTypes + \", but was actually of type \" + backtick(getType(value));\n};\nexport var assertIs = function (value, valueName, types) {\n  for (var idx = 0, len = types.length; idx < len; idx++) {\n    if (isType(value, types[idx])) return;\n  }\n  throw new TypeError(createTypeErrorMsg(value, valueName, types));\n};\nexport var assertOrUndefined = function (value, valueName, types) {\n  assertIs(value, valueName, types.concat('undefined'));\n};\nexport var assertEachIs = function (values, valueName, types) {\n  for (var idx = 0, len = values.length; idx < len; idx++) {\n    assertIs(values[idx], valueName, types);\n  }\n};\nexport var assertRange = function (value, valueName, min, max) {\n  assertIs(value, valueName, ['number']);\n  assertIs(min, 'min', ['number']);\n  assertIs(max, 'max', ['number']);\n  max = Math.max(min, max);\n  if (value < min || value > max) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be at least \" + min + \" and at most \" + max + \", but was actually \" + value);\n  }\n};\nexport var assertRangeOrUndefined = function (value, valueName, min, max) {\n  assertIs(value, valueName, ['number', 'undefined']);\n  if (typeof value === 'number') assertRange(value, valueName, min, max);\n};\nexport var assertMultiple = function (value, valueName, multiplier) {\n  assertIs(value, valueName, ['number']);\n  if (value % multiplier !== 0) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be a multiple of \" + multiplier + \", but was actually \" + value);\n  }\n};\nexport var assertInteger = function (value, valueName) {\n  if (!Number.isInteger(value)) {\n    throw new Error(backtick(valueName) + \" must be an integer, but was actually \" + value);\n  }\n};\nexport var assertPositive = function (value, valueName) {\n  if (![1, 0].includes(Math.sign(value))) {\n    // prettier-ignore\n    throw new Error(backtick(valueName) + \" must be a positive number or 0, but was actually \" + value);\n  }\n};","map":{"version":3,"sources":["../../src/utils/validators.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* tslint:disable:ban-types */\nimport { values as objectValues } from \"./objects\";\nexport var backtick = function (val) { return \"`\" + val + \"`\"; };\nexport var singleQuote = function (val) { return \"'\" + val + \"'\"; };\n// prettier-ignore\nvar formatValue = function (value) {\n    var type = typeof value;\n    if (type === 'string')\n        return singleQuote(value);\n    else if (type === 'undefined')\n        return backtick(value);\n    else\n        return value;\n};\nexport var createValueErrorMsg = function (value, valueName, values) {\n    var allowedValues = new Array(values.length);\n    for (var idx = 0, len = values.length; idx < len; idx++) {\n        var v = values[idx];\n        allowedValues[idx] = formatValue(v);\n    }\n    var joinedValues = allowedValues.join(' or ');\n    // prettier-ignore\n    return backtick(valueName) + \" must be one of \" + joinedValues + \", but was actually \" + formatValue(value);\n};\nexport var assertIsOneOf = function (value, valueName, allowedValues) {\n    if (!Array.isArray(allowedValues)) {\n        allowedValues = objectValues(allowedValues);\n    }\n    for (var idx = 0, len = allowedValues.length; idx < len; idx++) {\n        if (value === allowedValues[idx])\n            return;\n    }\n    throw new TypeError(createValueErrorMsg(value, valueName, allowedValues));\n};\nexport var assertIsOneOfOrUndefined = function (value, valueName, allowedValues) {\n    if (!Array.isArray(allowedValues)) {\n        allowedValues = objectValues(allowedValues);\n    }\n    assertIsOneOf(value, valueName, allowedValues.concat(undefined));\n};\nexport var assertIsSubset = function (values, valueName, allowedValues) {\n    if (!Array.isArray(allowedValues)) {\n        allowedValues = objectValues(allowedValues);\n    }\n    for (var idx = 0, len = values.length; idx < len; idx++) {\n        assertIsOneOf(values[idx], valueName, allowedValues);\n    }\n};\nexport var getType = function (val) {\n    if (val === null)\n        return 'null';\n    if (val === undefined)\n        return 'undefined';\n    if (typeof val === 'string')\n        return 'string';\n    if (isNaN(val))\n        return 'NaN';\n    if (typeof val === 'number')\n        return 'number';\n    if (typeof val === 'boolean')\n        return 'boolean';\n    if (typeof val === 'symbol')\n        return 'symbol';\n    if (typeof val === 'bigint')\n        return 'bigint';\n    if (val.constructor && val.constructor.name)\n        return val.constructor.name;\n    if (val.name)\n        return val.name;\n    if (val.constructor)\n        return String(val.constructor);\n    return String(val);\n};\nexport var isType = function (value, type) {\n    if (type === 'null')\n        return value === null;\n    if (type === 'undefined')\n        return value === undefined;\n    if (type === 'string')\n        return typeof value === 'string';\n    if (type === 'number')\n        return typeof value === 'number' && !isNaN(value);\n    if (type === 'boolean')\n        return typeof value === 'boolean';\n    if (type === 'symbol')\n        return typeof value === 'symbol';\n    if (type === 'bigint')\n        return typeof value === 'bigint';\n    if (type === Date)\n        return value instanceof Date;\n    if (type === Array)\n        return value instanceof Array;\n    if (type === Uint8Array)\n        return value instanceof Uint8Array;\n    if (type === ArrayBuffer)\n        return value instanceof ArrayBuffer;\n    if (type === Function)\n        return value instanceof Function;\n    return value instanceof type[0];\n};\nexport var createTypeErrorMsg = function (value, valueName, types) {\n    var allowedTypes = new Array(types.length);\n    for (var idx = 0, len = types.length; idx < len; idx++) {\n        var type = types[idx];\n        if (type === 'null')\n            allowedTypes[idx] = backtick('null');\n        if (type === 'undefined')\n            allowedTypes[idx] = backtick('undefined');\n        if (type === 'string')\n            allowedTypes[idx] = backtick('string');\n        else if (type === 'number')\n            allowedTypes[idx] = backtick('number');\n        else if (type === 'boolean')\n            allowedTypes[idx] = backtick('boolean');\n        else if (type === 'symbol')\n            allowedTypes[idx] = backtick('symbol');\n        else if (type === 'bigint')\n            allowedTypes[idx] = backtick('bigint');\n        else if (type === Array)\n            allowedTypes[idx] = backtick('Array');\n        else if (type === Uint8Array)\n            allowedTypes[idx] = backtick('Uint8Array');\n        else if (type === ArrayBuffer)\n            allowedTypes[idx] = backtick('ArrayBuffer');\n        else\n            allowedTypes[idx] = backtick(type[1]);\n    }\n    var joinedTypes = allowedTypes.join(' or ');\n    // prettier-ignore\n    return backtick(valueName) + \" must be of type \" + joinedTypes + \", but was actually of type \" + backtick(getType(value));\n};\nexport var assertIs = function (value, valueName, types) {\n    for (var idx = 0, len = types.length; idx < len; idx++) {\n        if (isType(value, types[idx]))\n            return;\n    }\n    throw new TypeError(createTypeErrorMsg(value, valueName, types));\n};\nexport var assertOrUndefined = function (value, valueName, types) {\n    assertIs(value, valueName, types.concat('undefined'));\n};\nexport var assertEachIs = function (values, valueName, types) {\n    for (var idx = 0, len = values.length; idx < len; idx++) {\n        assertIs(values[idx], valueName, types);\n    }\n};\nexport var assertRange = function (value, valueName, min, max) {\n    assertIs(value, valueName, ['number']);\n    assertIs(min, 'min', ['number']);\n    assertIs(max, 'max', ['number']);\n    max = Math.max(min, max);\n    if (value < min || value > max) {\n        // prettier-ignore\n        throw new Error(backtick(valueName) + \" must be at least \" + min + \" and at most \" + max + \", but was actually \" + value);\n    }\n};\nexport var assertRangeOrUndefined = function (value, valueName, min, max) {\n    assertIs(value, valueName, ['number', 'undefined']);\n    if (typeof value === 'number')\n        assertRange(value, valueName, min, max);\n};\nexport var assertMultiple = function (value, valueName, multiplier) {\n    assertIs(value, valueName, ['number']);\n    if (value % multiplier !== 0) {\n        // prettier-ignore\n        throw new Error(backtick(valueName) + \" must be a multiple of \" + multiplier + \", but was actually \" + value);\n    }\n};\nexport var assertInteger = function (value, valueName) {\n    if (!Number.isInteger(value)) {\n        throw new Error(backtick(valueName) + \" must be an integer, but was actually \" + value);\n    }\n};\nexport var assertPositive = function (value, valueName) {\n    if (![1, 0].includes(Math.sign(value))) {\n        // prettier-ignore\n        throw new Error(backtick(valueName) + \" must be a positive number or 0, but was actually \" + value);\n    }\n};\n//# sourceMappingURL=validators.js.map"]},"metadata":{},"sourceType":"module"}