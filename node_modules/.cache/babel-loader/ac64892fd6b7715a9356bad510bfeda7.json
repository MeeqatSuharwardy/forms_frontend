{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */function (_super) {\n  __extends(PDFParser, _super);\n  function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    if (objectsPerTick === void 0) {\n      objectsPerTick = Infinity;\n    }\n    if (throwOnInvalidObject === void 0) {\n      throwOnInvalidObject = false;\n    }\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n    _this.alreadyParsed = false;\n    _this.parsedObjects = 0;\n    _this.shouldWaitForTick = function () {\n      _this.parsedObjects += 1;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    _this.objectsPerTick = objectsPerTick;\n    _this.throwOnInvalidObject = throwOnInvalidObject;\n    return _this;\n  }\n  PDFParser.prototype.parseDocument = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var prevOffset, offset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.alreadyParsed) {\n              throw new ReparseError('PDFParser', 'parseDocument');\n            }\n            this.alreadyParsed = true;\n            this.context.header = this.parseHeader();\n            _a.label = 1;\n          case 1:\n            if (!!this.bytes.done()) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.parseDocumentSection()];\n          case 2:\n            _a.sent();\n            offset = this.bytes.offset();\n            if (offset === prevOffset) {\n              throw new StalledParserError(this.bytes.position());\n            }\n            prevOffset = offset;\n            return [3 /*break*/, 1];\n          case 3:\n            this.maybeRecoverRoot();\n            if (this.context.lookup(PDFRef.of(0))) {\n              console.warn('Removing parsed object: 0 0 R');\n              this.context.delete(PDFRef.of(0));\n            }\n            return [2 /*return*/, this.context];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeRecoverRoot = function () {\n    var isValidCatalog = function (obj) {\n      return obj instanceof PDFDict && obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n    };\n    var catalog = this.context.lookup(this.context.trailerInfo.Root);\n    if (!isValidCatalog(catalog)) {\n      var indirectObjects = this.context.enumerateIndirectObjects();\n      for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n        var _a = indirectObjects[idx],\n          ref = _a[0],\n          object = _a[1];\n        if (isValidCatalog(object)) {\n          this.context.trailerInfo.Root = ref;\n        }\n      }\n    }\n  };\n  PDFParser.prototype.parseHeader = function () {\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.header)) {\n        var major = this.parseRawInt();\n        this.bytes.assertNext(CharCodes.Period);\n        var minor = this.parseRawInt();\n        var header = PDFHeader.forVersion(major, minor);\n        this.skipBinaryHeaderComment();\n        return header;\n      }\n      this.bytes.next();\n    }\n    throw new MissingPDFHeaderError(this.bytes.position());\n  };\n  PDFParser.prototype.parseIndirectObjectHeader = function () {\n    this.skipWhitespaceAndComments();\n    var objectNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    var generationNumber = this.parseRawInt();\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.obj)) {\n      throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n    }\n    return PDFRef.of(objectNumber, generationNumber);\n  };\n  PDFParser.prototype.matchIndirectObjectHeader = function () {\n    var initialOffset = this.bytes.offset();\n    try {\n      this.parseIndirectObjectHeader();\n      return true;\n    } catch (e) {\n      this.bytes.moveTo(initialOffset);\n      return false;\n    }\n  };\n  PDFParser.prototype.parseIndirectObject = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var ref, object;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ref = this.parseIndirectObjectHeader();\n            this.skipWhitespaceAndComments();\n            object = this.parseObject();\n            this.skipWhitespaceAndComments();\n            // if (!this.matchKeyword(Keywords.endobj)) {\n            // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n            // }\n            // TODO: Log a warning if this fails...\n            this.matchKeyword(Keywords.endobj);\n            if (!(object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n            return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n          case 1:\n            _a.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            if (object instanceof PDFRawStream && object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n              PDFXRefStreamParser.forStream(object).parseIntoContext();\n            } else {\n              this.context.assign(ref, object);\n            }\n            _a.label = 3;\n          case 3:\n            return [2 /*return*/, ref];\n        }\n      });\n    });\n  };\n  // TODO: Improve and clean this up\n  PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n    var startPos = this.bytes.position();\n    var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n    if (this.throwOnInvalidObject) throw new Error(msg);\n    console.warn(msg);\n    var ref = this.parseIndirectObjectHeader();\n    console.warn(\"Invalid object ref: \" + ref);\n    this.skipWhitespaceAndComments();\n    var start = this.bytes.offset();\n    var failed = true;\n    while (!this.bytes.done()) {\n      if (this.matchKeyword(Keywords.endobj)) {\n        failed = false;\n      }\n      if (!failed) break;\n      this.bytes.next();\n    }\n    if (failed) throw new PDFInvalidObjectParsingError(startPos);\n    var end = this.bytes.offset() - Keywords.endobj.length;\n    var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n    this.context.assign(ref, object);\n    return ref;\n  };\n  PDFParser.prototype.parseIndirectObjects = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var initialOffset, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.skipWhitespaceAndComments();\n            _a.label = 1;\n          case 1:\n            if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n            initialOffset = this.bytes.offset();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.parseIndirectObject()];\n          case 3:\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_1 = _a.sent();\n            // TODO: Add tracing/logging mechanism to track when this happens!\n            this.bytes.moveTo(initialOffset);\n            this.tryToParseInvalidIndirectObject();\n            return [3 /*break*/, 5];\n          case 5:\n            this.skipWhitespaceAndComments();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n            return [4 /*yield*/, waitForTick()];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [3 /*break*/, 1];\n          case 8:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  PDFParser.prototype.maybeParseCrossRefSection = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.xref)) return;\n    this.skipWhitespaceAndComments();\n    var objectNumber = -1;\n    var xref = PDFCrossRefSection.createEmpty();\n    while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n      var firstInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var secondInt = this.parseRawInt();\n      this.skipWhitespaceAndComments();\n      var byte = this.bytes.peek();\n      if (byte === CharCodes.n || byte === CharCodes.f) {\n        var ref = PDFRef.of(objectNumber, secondInt);\n        if (this.bytes.next() === CharCodes.n) {\n          xref.addEntry(ref, firstInt);\n        } else {\n          // this.context.delete(ref);\n          xref.addDeletedEntry(ref, firstInt);\n        }\n        objectNumber += 1;\n      } else {\n        objectNumber = firstInt;\n      }\n      this.skipWhitespaceAndComments();\n    }\n    return xref;\n  };\n  PDFParser.prototype.maybeParseTrailerDict = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.trailer)) return;\n    this.skipWhitespaceAndComments();\n    var dict = this.parseDict();\n    var context = this.context;\n    context.trailerInfo = {\n      Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n      Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n      Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n      ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID\n    };\n  };\n  PDFParser.prototype.maybeParseTrailer = function () {\n    this.skipWhitespaceAndComments();\n    if (!this.matchKeyword(Keywords.startxref)) return;\n    this.skipWhitespaceAndComments();\n    var offset = this.parseRawInt();\n    this.skipWhitespace();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    this.matchKeyword(Keywords.eof);\n    this.skipWhitespaceAndComments();\n    return PDFTrailer.forLastCrossRefSectionOffset(offset);\n  };\n  PDFParser.prototype.parseDocumentSection = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4 /*yield*/, this.parseIndirectObjects()];\n          case 1:\n            _a.sent();\n            this.maybeParseCrossRefSection();\n            this.maybeParseTrailerDict();\n            this.maybeParseTrailer();\n            // TODO: Can this be done only when needed, to avoid harming performance?\n            this.skipJibberish();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\n   * This operation is not necessary for valid PDF files. But some invalid PDFs\n   * contain jibberish in between indirect objects. This method is designed to\n   * skip past that jibberish, should it exist, until it reaches the next\n   * indirect object header, an xref table section, or the file trailer.\n   */\n  PDFParser.prototype.skipJibberish = function () {\n    this.skipWhitespaceAndComments();\n    while (!this.bytes.done()) {\n      var initialOffset = this.bytes.offset();\n      var byte = this.bytes.peek();\n      var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n      if (isAlphaNumeric) {\n        if (this.matchKeyword(Keywords.xref) || this.matchKeyword(Keywords.trailer) || this.matchKeyword(Keywords.startxref) || this.matchIndirectObjectHeader()) {\n          this.bytes.moveTo(initialOffset);\n          break;\n        }\n      }\n      this.bytes.next();\n    }\n  };\n  /**\n   * Skips the binary comment following a PDF header. The specification\n   * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n   * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n   *\n   * This would imply that to strip out this binary comment, we could check for\n   * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n   * are 128 or greater. This works for many documents that properly comply with\n   * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n   * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n   * these headers correctly, we just throw out all bytes leading up to the\n   * first indirect object header.\n   */\n  PDFParser.prototype.skipBinaryHeaderComment = function () {\n    this.skipWhitespaceAndComments();\n    try {\n      var initialOffset = this.bytes.offset();\n      this.parseIndirectObjectHeader();\n      this.bytes.moveTo(initialOffset);\n    } catch (e) {\n      this.bytes.next();\n      this.skipWhitespaceAndComments();\n    }\n  };\n  PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n    return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n  };\n  return PDFParser;\n}(PDFObjectParser);\nexport default PDFParser;","map":{"version":3,"sources":["../../../src/core/parser/PDFParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __extends, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport { MissingKeywordError, MissingPDFHeaderError, PDFInvalidObjectParsingError, ReparseError, StalledParserError, } from \"../errors\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFInvalidObject from \"../objects/PDFInvalidObject\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFRawStream from \"../objects/PDFRawStream\";\nimport PDFRef from \"../objects/PDFRef\";\nimport ByteStream from \"./ByteStream\";\nimport PDFObjectParser from \"./PDFObjectParser\";\nimport PDFObjectStreamParser from \"./PDFObjectStreamParser\";\nimport PDFXRefStreamParser from \"./PDFXRefStreamParser\";\nimport PDFContext from \"../PDFContext\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { Keywords } from \"../syntax/Keywords\";\nimport { IsDigit } from \"../syntax/Numeric\";\nimport { waitForTick } from \"../../utils\";\nvar PDFParser = /** @class */ (function (_super) {\n    __extends(PDFParser, _super);\n    function PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        if (objectsPerTick === void 0) { objectsPerTick = Infinity; }\n        if (throwOnInvalidObject === void 0) { throwOnInvalidObject = false; }\n        if (capNumbers === void 0) { capNumbers = false; }\n        var _this = _super.call(this, ByteStream.of(pdfBytes), PDFContext.create(), capNumbers) || this;\n        _this.alreadyParsed = false;\n        _this.parsedObjects = 0;\n        _this.shouldWaitForTick = function () {\n            _this.parsedObjects += 1;\n            return _this.parsedObjects % _this.objectsPerTick === 0;\n        };\n        _this.objectsPerTick = objectsPerTick;\n        _this.throwOnInvalidObject = throwOnInvalidObject;\n        return _this;\n    }\n    PDFParser.prototype.parseDocument = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var prevOffset, offset;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.alreadyParsed) {\n                            throw new ReparseError('PDFParser', 'parseDocument');\n                        }\n                        this.alreadyParsed = true;\n                        this.context.header = this.parseHeader();\n                        _a.label = 1;\n                    case 1:\n                        if (!!this.bytes.done()) return [3 /*break*/, 3];\n                        return [4 /*yield*/, this.parseDocumentSection()];\n                    case 2:\n                        _a.sent();\n                        offset = this.bytes.offset();\n                        if (offset === prevOffset) {\n                            throw new StalledParserError(this.bytes.position());\n                        }\n                        prevOffset = offset;\n                        return [3 /*break*/, 1];\n                    case 3:\n                        this.maybeRecoverRoot();\n                        if (this.context.lookup(PDFRef.of(0))) {\n                            console.warn('Removing parsed object: 0 0 R');\n                            this.context.delete(PDFRef.of(0));\n                        }\n                        return [2 /*return*/, this.context];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeRecoverRoot = function () {\n        var isValidCatalog = function (obj) {\n            return obj instanceof PDFDict &&\n                obj.lookup(PDFName.of('Type')) === PDFName.of('Catalog');\n        };\n        var catalog = this.context.lookup(this.context.trailerInfo.Root);\n        if (!isValidCatalog(catalog)) {\n            var indirectObjects = this.context.enumerateIndirectObjects();\n            for (var idx = 0, len = indirectObjects.length; idx < len; idx++) {\n                var _a = indirectObjects[idx], ref = _a[0], object = _a[1];\n                if (isValidCatalog(object)) {\n                    this.context.trailerInfo.Root = ref;\n                }\n            }\n        }\n    };\n    PDFParser.prototype.parseHeader = function () {\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.header)) {\n                var major = this.parseRawInt();\n                this.bytes.assertNext(CharCodes.Period);\n                var minor = this.parseRawInt();\n                var header = PDFHeader.forVersion(major, minor);\n                this.skipBinaryHeaderComment();\n                return header;\n            }\n            this.bytes.next();\n        }\n        throw new MissingPDFHeaderError(this.bytes.position());\n    };\n    PDFParser.prototype.parseIndirectObjectHeader = function () {\n        this.skipWhitespaceAndComments();\n        var objectNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        var generationNumber = this.parseRawInt();\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.obj)) {\n            throw new MissingKeywordError(this.bytes.position(), Keywords.obj);\n        }\n        return PDFRef.of(objectNumber, generationNumber);\n    };\n    PDFParser.prototype.matchIndirectObjectHeader = function () {\n        var initialOffset = this.bytes.offset();\n        try {\n            this.parseIndirectObjectHeader();\n            return true;\n        }\n        catch (e) {\n            this.bytes.moveTo(initialOffset);\n            return false;\n        }\n    };\n    PDFParser.prototype.parseIndirectObject = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var ref, object;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        ref = this.parseIndirectObjectHeader();\n                        this.skipWhitespaceAndComments();\n                        object = this.parseObject();\n                        this.skipWhitespaceAndComments();\n                        // if (!this.matchKeyword(Keywords.endobj)) {\n                        // throw new MissingKeywordError(this.bytes.position(), Keywords.endobj);\n                        // }\n                        // TODO: Log a warning if this fails...\n                        this.matchKeyword(Keywords.endobj);\n                        if (!(object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('ObjStm'))) return [3 /*break*/, 2];\n                        return [4 /*yield*/, PDFObjectStreamParser.forStream(object, this.shouldWaitForTick).parseIntoContext()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (object instanceof PDFRawStream &&\n                            object.dict.lookup(PDFName.of('Type')) === PDFName.of('XRef')) {\n                            PDFXRefStreamParser.forStream(object).parseIntoContext();\n                        }\n                        else {\n                            this.context.assign(ref, object);\n                        }\n                        _a.label = 3;\n                    case 3: return [2 /*return*/, ref];\n                }\n            });\n        });\n    };\n    // TODO: Improve and clean this up\n    PDFParser.prototype.tryToParseInvalidIndirectObject = function () {\n        var startPos = this.bytes.position();\n        var msg = \"Trying to parse invalid object: \" + JSON.stringify(startPos) + \")\";\n        if (this.throwOnInvalidObject)\n            throw new Error(msg);\n        console.warn(msg);\n        var ref = this.parseIndirectObjectHeader();\n        console.warn(\"Invalid object ref: \" + ref);\n        this.skipWhitespaceAndComments();\n        var start = this.bytes.offset();\n        var failed = true;\n        while (!this.bytes.done()) {\n            if (this.matchKeyword(Keywords.endobj)) {\n                failed = false;\n            }\n            if (!failed)\n                break;\n            this.bytes.next();\n        }\n        if (failed)\n            throw new PDFInvalidObjectParsingError(startPos);\n        var end = this.bytes.offset() - Keywords.endobj.length;\n        var object = PDFInvalidObject.of(this.bytes.slice(start, end));\n        this.context.assign(ref, object);\n        return ref;\n    };\n    PDFParser.prototype.parseIndirectObjects = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var initialOffset, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.skipWhitespaceAndComments();\n                        _a.label = 1;\n                    case 1:\n                        if (!(!this.bytes.done() && IsDigit[this.bytes.peek()])) return [3 /*break*/, 8];\n                        initialOffset = this.bytes.offset();\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.parseIndirectObject()];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_1 = _a.sent();\n                        // TODO: Add tracing/logging mechanism to track when this happens!\n                        this.bytes.moveTo(initialOffset);\n                        this.tryToParseInvalidIndirectObject();\n                        return [3 /*break*/, 5];\n                    case 5:\n                        this.skipWhitespaceAndComments();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        if (!this.shouldWaitForTick()) return [3 /*break*/, 7];\n                        return [4 /*yield*/, waitForTick()];\n                    case 6:\n                        _a.sent();\n                        _a.label = 7;\n                    case 7: return [3 /*break*/, 1];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    PDFParser.prototype.maybeParseCrossRefSection = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.xref))\n            return;\n        this.skipWhitespaceAndComments();\n        var objectNumber = -1;\n        var xref = PDFCrossRefSection.createEmpty();\n        while (!this.bytes.done() && IsDigit[this.bytes.peek()]) {\n            var firstInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var secondInt = this.parseRawInt();\n            this.skipWhitespaceAndComments();\n            var byte = this.bytes.peek();\n            if (byte === CharCodes.n || byte === CharCodes.f) {\n                var ref = PDFRef.of(objectNumber, secondInt);\n                if (this.bytes.next() === CharCodes.n) {\n                    xref.addEntry(ref, firstInt);\n                }\n                else {\n                    // this.context.delete(ref);\n                    xref.addDeletedEntry(ref, firstInt);\n                }\n                objectNumber += 1;\n            }\n            else {\n                objectNumber = firstInt;\n            }\n            this.skipWhitespaceAndComments();\n        }\n        return xref;\n    };\n    PDFParser.prototype.maybeParseTrailerDict = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.trailer))\n            return;\n        this.skipWhitespaceAndComments();\n        var dict = this.parseDict();\n        var context = this.context;\n        context.trailerInfo = {\n            Root: dict.get(PDFName.of('Root')) || context.trailerInfo.Root,\n            Encrypt: dict.get(PDFName.of('Encrypt')) || context.trailerInfo.Encrypt,\n            Info: dict.get(PDFName.of('Info')) || context.trailerInfo.Info,\n            ID: dict.get(PDFName.of('ID')) || context.trailerInfo.ID,\n        };\n    };\n    PDFParser.prototype.maybeParseTrailer = function () {\n        this.skipWhitespaceAndComments();\n        if (!this.matchKeyword(Keywords.startxref))\n            return;\n        this.skipWhitespaceAndComments();\n        var offset = this.parseRawInt();\n        this.skipWhitespace();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        this.matchKeyword(Keywords.eof);\n        this.skipWhitespaceAndComments();\n        return PDFTrailer.forLastCrossRefSectionOffset(offset);\n    };\n    PDFParser.prototype.parseDocumentSection = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.parseIndirectObjects()];\n                    case 1:\n                        _a.sent();\n                        this.maybeParseCrossRefSection();\n                        this.maybeParseTrailerDict();\n                        this.maybeParseTrailer();\n                        // TODO: Can this be done only when needed, to avoid harming performance?\n                        this.skipJibberish();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This operation is not necessary for valid PDF files. But some invalid PDFs\n     * contain jibberish in between indirect objects. This method is designed to\n     * skip past that jibberish, should it exist, until it reaches the next\n     * indirect object header, an xref table section, or the file trailer.\n     */\n    PDFParser.prototype.skipJibberish = function () {\n        this.skipWhitespaceAndComments();\n        while (!this.bytes.done()) {\n            var initialOffset = this.bytes.offset();\n            var byte = this.bytes.peek();\n            var isAlphaNumeric = byte >= CharCodes.Space && byte <= CharCodes.Tilde;\n            if (isAlphaNumeric) {\n                if (this.matchKeyword(Keywords.xref) ||\n                    this.matchKeyword(Keywords.trailer) ||\n                    this.matchKeyword(Keywords.startxref) ||\n                    this.matchIndirectObjectHeader()) {\n                    this.bytes.moveTo(initialOffset);\n                    break;\n                }\n            }\n            this.bytes.next();\n        }\n    };\n    /**\n     * Skips the binary comment following a PDF header. The specification\n     * defines this binary comment (section 7.5.2 File Header) as a sequence of 4\n     * or more bytes that are 128 or greater, and which are preceded by a \"%\".\n     *\n     * This would imply that to strip out this binary comment, we could check for\n     * a sequence of bytes starting with \"%\", and remove all subsequent bytes that\n     * are 128 or greater. This works for many documents that properly comply with\n     * the spec. But in the wild, there are PDFs that omit the leading \"%\", and\n     * include bytes that are less than 128 (e.g. 0 or 1). So in order to parse\n     * these headers correctly, we just throw out all bytes leading up to the\n     * first indirect object header.\n     */\n    PDFParser.prototype.skipBinaryHeaderComment = function () {\n        this.skipWhitespaceAndComments();\n        try {\n            var initialOffset = this.bytes.offset();\n            this.parseIndirectObjectHeader();\n            this.bytes.moveTo(initialOffset);\n        }\n        catch (e) {\n            this.bytes.next();\n            this.skipWhitespaceAndComments();\n        }\n    };\n    PDFParser.forBytesWithOptions = function (pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers) {\n        return new PDFParser(pdfBytes, objectsPerTick, throwOnInvalidObject, capNumbers);\n    };\n    return PDFParser;\n}(PDFObjectParser));\nexport default PDFParser;\n//# sourceMappingURL=PDFParser.js.map"]},"metadata":{},"sourceType":"module"}