{"ast":null,"code":"import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\nvar emptyBuffer = new Uint8Array(0);\n/**\n * Super class for the decoding streams\n */\nvar DecodeStream = /** @class */function () {\n  function DecodeStream(maybeMinBufferLength) {\n    this.pos = 0;\n    this.bufferLength = 0;\n    this.eof = false;\n    this.buffer = emptyBuffer;\n    this.minBufferLength = 512;\n    if (maybeMinBufferLength) {\n      // Compute the first power of two that is as big as maybeMinBufferLength.\n      while (this.minBufferLength < maybeMinBufferLength) {\n        this.minBufferLength *= 2;\n      }\n    }\n  }\n  Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n    get: function () {\n      while (!this.eof && this.bufferLength === 0) {\n        this.readBlock();\n      }\n      return this.bufferLength === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  DecodeStream.prototype.getByte = function () {\n    var pos = this.pos;\n    while (this.bufferLength <= pos) {\n      if (this.eof) {\n        return -1;\n      }\n      this.readBlock();\n    }\n    return this.buffer[this.pos++];\n  };\n  DecodeStream.prototype.getUint16 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    if (b0 === -1 || b1 === -1) {\n      return -1;\n    }\n    return (b0 << 8) + b1;\n  };\n  DecodeStream.prototype.getInt32 = function () {\n    var b0 = this.getByte();\n    var b1 = this.getByte();\n    var b2 = this.getByte();\n    var b3 = this.getByte();\n    return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n  };\n  DecodeStream.prototype.getBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var end;\n    var pos = this.pos;\n    if (length) {\n      this.ensureBuffer(pos + length);\n      end = pos + length;\n      while (!this.eof && this.bufferLength < end) {\n        this.readBlock();\n      }\n      var bufEnd = this.bufferLength;\n      if (end > bufEnd) {\n        end = bufEnd;\n      }\n    } else {\n      while (!this.eof) {\n        this.readBlock();\n      }\n      end = this.bufferLength;\n    }\n    this.pos = end;\n    var subarray = this.buffer.subarray(pos, end);\n    // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n    return forceClamped && !(subarray instanceof Uint8ClampedArray) ? new Uint8ClampedArray(subarray) : subarray;\n  };\n  DecodeStream.prototype.peekByte = function () {\n    var peekedByte = this.getByte();\n    this.pos--;\n    return peekedByte;\n  };\n  DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n    if (forceClamped === void 0) {\n      forceClamped = false;\n    }\n    var bytes = this.getBytes(length, forceClamped);\n    this.pos -= bytes.length;\n    return bytes;\n  };\n  DecodeStream.prototype.skip = function (n) {\n    if (!n) {\n      n = 1;\n    }\n    this.pos += n;\n  };\n  DecodeStream.prototype.reset = function () {\n    this.pos = 0;\n  };\n  DecodeStream.prototype.makeSubStream = function (start, length /* dict */) {\n    var end = start + length;\n    while (this.bufferLength <= end && !this.eof) {\n      this.readBlock();\n    }\n    return new Stream(this.buffer, start, length /* dict */);\n  };\n  DecodeStream.prototype.decode = function () {\n    while (!this.eof) this.readBlock();\n    return this.buffer.subarray(0, this.bufferLength);\n  };\n  DecodeStream.prototype.readBlock = function () {\n    throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n  };\n  DecodeStream.prototype.ensureBuffer = function (requested) {\n    var buffer = this.buffer;\n    if (requested <= buffer.byteLength) {\n      return buffer;\n    }\n    var size = this.minBufferLength;\n    while (size < requested) {\n      size *= 2;\n    }\n    var buffer2 = new Uint8Array(size);\n    buffer2.set(buffer);\n    return this.buffer = buffer2;\n  };\n  return DecodeStream;\n}();\nexport default DecodeStream;","map":{"version":3,"sources":["../../../src/core/streams/DecodeStream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MethodNotImplementedError } from \"../errors\";\nimport Stream from \"./Stream\";\n/*\n * Copyright 2012 Mozilla Foundation\n *\n * The DecodeStream class contained in this file is a TypeScript port of the\n * JavaScript DecodeStream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\n// Lots of DecodeStreams are created whose buffers are never used.  For these\n// we share a single empty buffer. This is (a) space-efficient and (b) avoids\n// having special cases that would be required if we used |null| for an empty\n// buffer.\nvar emptyBuffer = new Uint8Array(0);\n/**\n * Super class for the decoding streams\n */\nvar DecodeStream = /** @class */ (function () {\n    function DecodeStream(maybeMinBufferLength) {\n        this.pos = 0;\n        this.bufferLength = 0;\n        this.eof = false;\n        this.buffer = emptyBuffer;\n        this.minBufferLength = 512;\n        if (maybeMinBufferLength) {\n            // Compute the first power of two that is as big as maybeMinBufferLength.\n            while (this.minBufferLength < maybeMinBufferLength) {\n                this.minBufferLength *= 2;\n            }\n        }\n    }\n    Object.defineProperty(DecodeStream.prototype, \"isEmpty\", {\n        get: function () {\n            while (!this.eof && this.bufferLength === 0) {\n                this.readBlock();\n            }\n            return this.bufferLength === 0;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DecodeStream.prototype.getByte = function () {\n        var pos = this.pos;\n        while (this.bufferLength <= pos) {\n            if (this.eof) {\n                return -1;\n            }\n            this.readBlock();\n        }\n        return this.buffer[this.pos++];\n    };\n    DecodeStream.prototype.getUint16 = function () {\n        var b0 = this.getByte();\n        var b1 = this.getByte();\n        if (b0 === -1 || b1 === -1) {\n            return -1;\n        }\n        return (b0 << 8) + b1;\n    };\n    DecodeStream.prototype.getInt32 = function () {\n        var b0 = this.getByte();\n        var b1 = this.getByte();\n        var b2 = this.getByte();\n        var b3 = this.getByte();\n        return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;\n    };\n    DecodeStream.prototype.getBytes = function (length, forceClamped) {\n        if (forceClamped === void 0) { forceClamped = false; }\n        var end;\n        var pos = this.pos;\n        if (length) {\n            this.ensureBuffer(pos + length);\n            end = pos + length;\n            while (!this.eof && this.bufferLength < end) {\n                this.readBlock();\n            }\n            var bufEnd = this.bufferLength;\n            if (end > bufEnd) {\n                end = bufEnd;\n            }\n        }\n        else {\n            while (!this.eof) {\n                this.readBlock();\n            }\n            end = this.bufferLength;\n        }\n        this.pos = end;\n        var subarray = this.buffer.subarray(pos, end);\n        // `this.buffer` is either a `Uint8Array` or `Uint8ClampedArray` here.\n        return forceClamped && !(subarray instanceof Uint8ClampedArray)\n            ? new Uint8ClampedArray(subarray)\n            : subarray;\n    };\n    DecodeStream.prototype.peekByte = function () {\n        var peekedByte = this.getByte();\n        this.pos--;\n        return peekedByte;\n    };\n    DecodeStream.prototype.peekBytes = function (length, forceClamped) {\n        if (forceClamped === void 0) { forceClamped = false; }\n        var bytes = this.getBytes(length, forceClamped);\n        this.pos -= bytes.length;\n        return bytes;\n    };\n    DecodeStream.prototype.skip = function (n) {\n        if (!n) {\n            n = 1;\n        }\n        this.pos += n;\n    };\n    DecodeStream.prototype.reset = function () {\n        this.pos = 0;\n    };\n    DecodeStream.prototype.makeSubStream = function (start, length /* dict */) {\n        var end = start + length;\n        while (this.bufferLength <= end && !this.eof) {\n            this.readBlock();\n        }\n        return new Stream(this.buffer, start, length /* dict */);\n    };\n    DecodeStream.prototype.decode = function () {\n        while (!this.eof)\n            this.readBlock();\n        return this.buffer.subarray(0, this.bufferLength);\n    };\n    DecodeStream.prototype.readBlock = function () {\n        throw new MethodNotImplementedError(this.constructor.name, 'readBlock');\n    };\n    DecodeStream.prototype.ensureBuffer = function (requested) {\n        var buffer = this.buffer;\n        if (requested <= buffer.byteLength) {\n            return buffer;\n        }\n        var size = this.minBufferLength;\n        while (size < requested) {\n            size *= 2;\n        }\n        var buffer2 = new Uint8Array(size);\n        buffer2.set(buffer);\n        return (this.buffer = buffer2);\n    };\n    return DecodeStream;\n}());\nexport default DecodeStream;\n//# sourceMappingURL=DecodeStream.js.map"]},"metadata":{},"sourceType":"module"}