{"ast":null,"code":"/*\n * Copyright 2012 Mozilla Foundation\n *\n * The Ascii85Stream class contained in this file is a TypeScript port of the\n * JavaScript Ascii85Stream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar isSpace = function (ch) {\n  return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;\n};\nvar Ascii85Stream = /** @class */function (_super) {\n  __extends(Ascii85Stream, _super);\n  function Ascii85Stream(stream, maybeLength) {\n    var _this = _super.call(this, maybeLength) || this;\n    _this.stream = stream;\n    _this.input = new Uint8Array(5);\n    // Most streams increase in size when decoded, but Ascii85 streams\n    // typically shrink by ~20%.\n    if (maybeLength) {\n      maybeLength = 0.8 * maybeLength;\n    }\n    return _this;\n  }\n  Ascii85Stream.prototype.readBlock = function () {\n    var TILDA_CHAR = 0x7e; // '~'\n    var Z_LOWER_CHAR = 0x7a; // 'z'\n    var EOF = -1;\n    var stream = this.stream;\n    var c = stream.getByte();\n    while (isSpace(c)) {\n      c = stream.getByte();\n    }\n    if (c === EOF || c === TILDA_CHAR) {\n      this.eof = true;\n      return;\n    }\n    var bufferLength = this.bufferLength;\n    var buffer;\n    var i;\n    // special code for z\n    if (c === Z_LOWER_CHAR) {\n      buffer = this.ensureBuffer(bufferLength + 4);\n      for (i = 0; i < 4; ++i) {\n        buffer[bufferLength + i] = 0;\n      }\n      this.bufferLength += 4;\n    } else {\n      var input = this.input;\n      input[0] = c;\n      for (i = 1; i < 5; ++i) {\n        c = stream.getByte();\n        while (isSpace(c)) {\n          c = stream.getByte();\n        }\n        input[i] = c;\n        if (c === EOF || c === TILDA_CHAR) {\n          break;\n        }\n      }\n      buffer = this.ensureBuffer(bufferLength + i - 1);\n      this.bufferLength += i - 1;\n      // partial ending;\n      if (i < 5) {\n        for (; i < 5; ++i) {\n          input[i] = 0x21 + 84;\n        }\n        this.eof = true;\n      }\n      var t = 0;\n      for (i = 0; i < 5; ++i) {\n        t = t * 85 + (input[i] - 0x21);\n      }\n      for (i = 3; i >= 0; --i) {\n        buffer[bufferLength + i] = t & 0xff;\n        t >>= 8;\n      }\n    }\n  };\n  return Ascii85Stream;\n}(DecodeStream);\nexport default Ascii85Stream;","map":{"version":3,"sources":["../../../src/core/streams/Ascii85Stream.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2012 Mozilla Foundation\n *\n * The Ascii85Stream class contained in this file is a TypeScript port of the\n * JavaScript Ascii85Stream class in Mozilla's pdf.js project, made available\n * under the Apache 2.0 open source license.\n */\nimport { __extends } from \"tslib\";\nimport DecodeStream from \"./DecodeStream\";\nvar isSpace = function (ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0d || ch === 0x0a;\n};\nvar Ascii85Stream = /** @class */ (function (_super) {\n    __extends(Ascii85Stream, _super);\n    function Ascii85Stream(stream, maybeLength) {\n        var _this = _super.call(this, maybeLength) || this;\n        _this.stream = stream;\n        _this.input = new Uint8Array(5);\n        // Most streams increase in size when decoded, but Ascii85 streams\n        // typically shrink by ~20%.\n        if (maybeLength) {\n            maybeLength = 0.8 * maybeLength;\n        }\n        return _this;\n    }\n    Ascii85Stream.prototype.readBlock = function () {\n        var TILDA_CHAR = 0x7e; // '~'\n        var Z_LOWER_CHAR = 0x7a; // 'z'\n        var EOF = -1;\n        var stream = this.stream;\n        var c = stream.getByte();\n        while (isSpace(c)) {\n            c = stream.getByte();\n        }\n        if (c === EOF || c === TILDA_CHAR) {\n            this.eof = true;\n            return;\n        }\n        var bufferLength = this.bufferLength;\n        var buffer;\n        var i;\n        // special code for z\n        if (c === Z_LOWER_CHAR) {\n            buffer = this.ensureBuffer(bufferLength + 4);\n            for (i = 0; i < 4; ++i) {\n                buffer[bufferLength + i] = 0;\n            }\n            this.bufferLength += 4;\n        }\n        else {\n            var input = this.input;\n            input[0] = c;\n            for (i = 1; i < 5; ++i) {\n                c = stream.getByte();\n                while (isSpace(c)) {\n                    c = stream.getByte();\n                }\n                input[i] = c;\n                if (c === EOF || c === TILDA_CHAR) {\n                    break;\n                }\n            }\n            buffer = this.ensureBuffer(bufferLength + i - 1);\n            this.bufferLength += i - 1;\n            // partial ending;\n            if (i < 5) {\n                for (; i < 5; ++i) {\n                    input[i] = 0x21 + 84;\n                }\n                this.eof = true;\n            }\n            var t = 0;\n            for (i = 0; i < 5; ++i) {\n                t = t * 85 + (input[i] - 0x21);\n            }\n            for (i = 3; i >= 0; --i) {\n                buffer[bufferLength + i] = t & 0xff;\n                t >>= 8;\n            }\n        }\n    };\n    return Ascii85Stream;\n}(DecodeStream));\nexport default Ascii85Stream;\n//# sourceMappingURL=Ascii85Stream.js.map"]},"metadata":{},"sourceType":"module"}