{"ast":null,"code":"import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline,\n  CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */function () {\n  function BaseParser(bytes, capNumbers) {\n    if (capNumbers === void 0) {\n      capNumbers = false;\n    }\n    this.bytes = bytes;\n    this.capNumbers = capNumbers;\n  }\n  BaseParser.prototype.parseRawInt = function () {\n    var value = '';\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    return numberValue;\n  };\n  // TODO: Maybe handle exponential format?\n  // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n  BaseParser.prototype.parseRawNumber = function () {\n    var value = '';\n    // Parse integer-part, the leading (+ | - | . | 0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsNumeric[byte]) break;\n      value += charFromCode(this.bytes.next());\n      if (byte === CharCodes.Period) break;\n    }\n    // Parse decimal-part, the trailing (0-9)\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (!IsDigit[byte]) break;\n      value += charFromCode(this.bytes.next());\n    }\n    var numberValue = Number(value);\n    if (!value || !isFinite(numberValue)) {\n      throw new NumberParsingError(this.bytes.position(), value);\n    }\n    if (numberValue > Number.MAX_SAFE_INTEGER) {\n      if (this.capNumbers) {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n        console.warn(msg);\n        return Number.MAX_SAFE_INTEGER;\n      } else {\n        var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n        console.warn(msg);\n      }\n    }\n    return numberValue;\n  };\n  BaseParser.prototype.skipWhitespace = function () {\n    while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipLine = function () {\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return;\n      this.bytes.next();\n    }\n  };\n  BaseParser.prototype.skipComment = function () {\n    if (this.bytes.peek() !== CharCodes.Percent) return false;\n    while (!this.bytes.done()) {\n      var byte = this.bytes.peek();\n      if (byte === Newline || byte === CarriageReturn) return true;\n      this.bytes.next();\n    }\n    return true;\n  };\n  BaseParser.prototype.skipWhitespaceAndComments = function () {\n    this.skipWhitespace();\n    while (this.skipComment()) this.skipWhitespace();\n  };\n  BaseParser.prototype.matchKeyword = function (keyword) {\n    var initialOffset = this.bytes.offset();\n    for (var idx = 0, len = keyword.length; idx < len; idx++) {\n      if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n        this.bytes.moveTo(initialOffset);\n        return false;\n      }\n    }\n    return true;\n  };\n  return BaseParser;\n}();\nexport default BaseParser;","map":{"version":3,"sources":["../../../src/core/parser/BaseParser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NumberParsingError } from \"../errors\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { IsDigit, IsNumeric } from \"../syntax/Numeric\";\nimport { IsWhitespace } from \"../syntax/Whitespace\";\nimport { charFromCode } from \"../../utils\";\nvar Newline = CharCodes.Newline, CarriageReturn = CharCodes.CarriageReturn;\n// TODO: Throw error if eof is reached before finishing object parse...\nvar BaseParser = /** @class */ (function () {\n    function BaseParser(bytes, capNumbers) {\n        if (capNumbers === void 0) { capNumbers = false; }\n        this.bytes = bytes;\n        this.capNumbers = capNumbers;\n    }\n    BaseParser.prototype.parseRawInt = function () {\n        var value = '';\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        return numberValue;\n    };\n    // TODO: Maybe handle exponential format?\n    // TODO: Compare performance of string concatenation to charFromCode(...bytes)\n    BaseParser.prototype.parseRawNumber = function () {\n        var value = '';\n        // Parse integer-part, the leading (+ | - | . | 0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsNumeric[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n            if (byte === CharCodes.Period)\n                break;\n        }\n        // Parse decimal-part, the trailing (0-9)\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (!IsDigit[byte])\n                break;\n            value += charFromCode(this.bytes.next());\n        }\n        var numberValue = Number(value);\n        if (!value || !isFinite(numberValue)) {\n            throw new NumberParsingError(this.bytes.position(), value);\n        }\n        if (numberValue > Number.MAX_SAFE_INTEGER) {\n            if (this.capNumbers) {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", using Number.MAX_SAFE_INTEGER instead.\";\n                console.warn(msg);\n                return Number.MAX_SAFE_INTEGER;\n            }\n            else {\n                var msg = \"Parsed number that is too large for some PDF readers: \" + value + \", not capping.\";\n                console.warn(msg);\n            }\n        }\n        return numberValue;\n    };\n    BaseParser.prototype.skipWhitespace = function () {\n        while (!this.bytes.done() && IsWhitespace[this.bytes.peek()]) {\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipLine = function () {\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return;\n            this.bytes.next();\n        }\n    };\n    BaseParser.prototype.skipComment = function () {\n        if (this.bytes.peek() !== CharCodes.Percent)\n            return false;\n        while (!this.bytes.done()) {\n            var byte = this.bytes.peek();\n            if (byte === Newline || byte === CarriageReturn)\n                return true;\n            this.bytes.next();\n        }\n        return true;\n    };\n    BaseParser.prototype.skipWhitespaceAndComments = function () {\n        this.skipWhitespace();\n        while (this.skipComment())\n            this.skipWhitespace();\n    };\n    BaseParser.prototype.matchKeyword = function (keyword) {\n        var initialOffset = this.bytes.offset();\n        for (var idx = 0, len = keyword.length; idx < len; idx++) {\n            if (this.bytes.done() || this.bytes.next() !== keyword[idx]) {\n                this.bytes.moveTo(initialOffset);\n                return false;\n            }\n        }\n        return true;\n    };\n    return BaseParser;\n}());\nexport default BaseParser;\n//# sourceMappingURL=BaseParser.js.map"]},"metadata":{},"sourceType":"module"}