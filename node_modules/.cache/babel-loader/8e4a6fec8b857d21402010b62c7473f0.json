{"ast":null,"code":"import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n  if (multiline === void 0) {\n    multiline = false;\n  }\n  var fontSize = MIN_FONT_SIZE;\n  while (fontSize < MAX_FONT_SIZE) {\n    var linesUsed = 0;\n    for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n      linesUsed += 1;\n      var line = lines[lineIdx];\n      var words = line.split(' ');\n      // Layout the words using the current `fontSize`, line wrapping\n      // whenever we reach the end of the current line.\n      var spaceInLineRemaining = bounds.width;\n      for (var idx = 0, len = words.length; idx < len; idx++) {\n        var isLastWord = idx === len - 1;\n        var word = isLastWord ? words[idx] : words[idx] + ' ';\n        var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n        spaceInLineRemaining -= widthOfWord;\n        if (spaceInLineRemaining <= 0) {\n          linesUsed += 1;\n          spaceInLineRemaining = bounds.width - widthOfWord;\n        }\n      }\n    }\n    // Return if we exceeded the allowed width\n    if (!multiline && linesUsed > lines.length) return fontSize - 1;\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var totalHeight = lineHeight * linesUsed;\n    // Return if we exceeded the allowed height\n    if (totalHeight > Math.abs(bounds.height)) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n  var cellWidth = bounds.width / cellCount;\n  var cellHeight = bounds.height;\n  var fontSize = MIN_FONT_SIZE;\n  var chars = charSplit(line);\n  while (fontSize < MAX_FONT_SIZE) {\n    for (var idx = 0, len = chars.length; idx < len; idx++) {\n      var c = chars[idx];\n      var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n      if (tooLong) return fontSize - 1;\n    }\n    var height = font.heightAtSize(fontSize, {\n      descender: false\n    });\n    if (height > cellHeight) return fontSize - 1;\n    fontSize += 1;\n  }\n  return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n  for (var idx = line.length; idx > 0; idx--) {\n    if (/\\s/.test(line[idx])) return idx;\n  }\n  return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n  var _a;\n  var lastWhitespaceIdx = input.length;\n  while (lastWhitespaceIdx > 0) {\n    var line = input.substring(0, lastWhitespaceIdx);\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    if (width < maxWidth) {\n      var remainder = input.substring(lastWhitespaceIdx) || undefined;\n      return {\n        line: line,\n        encoded: encoded,\n        width: width,\n        remainder: remainder\n      };\n    }\n    lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n  }\n  // We were unable to split the input enough to get a chunk that would fit\n  // within the specified `maxWidth` so we'll just return everything\n  return {\n    line: input,\n    encoded: font.encodeText(input),\n    width: font.widthOfTextAtSize(input, fontSize),\n    remainder: undefined\n  };\n};\nexport var layoutMultilineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var lines = lineSplit(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize(lines, font, bounds, true);\n  }\n  var height = font.heightAtSize(fontSize);\n  var lineHeight = height + height * 0.2;\n  var textLines = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var y = bounds.y + bounds.height;\n  for (var idx = 0, len = lines.length; idx < len; idx++) {\n    var prevRemainder = lines[idx];\n    while (prevRemainder !== undefined) {\n      var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize),\n        line = _b.line,\n        encoded = _b.encoded,\n        width = _b.width,\n        remainder = _b.remainder;\n      // prettier-ignore\n      var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n      y -= lineHeight;\n      if (x < minX) minX = x;\n      if (y < minY) minY = y;\n      if (x + width > maxX) maxX = x + width;\n      if (y + height > maxY) maxY = y + height;\n      textLines.push({\n        text: line,\n        encoded: encoded,\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      });\n      // Only trim lines that we had to split ourselves. So we won't trim lines\n      // that the user provided themselves with whitespace.\n      prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n    }\n  }\n  return {\n    fontSize: fontSize,\n    lineHeight: lineHeight,\n    lines: textLines,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutCombedText = function (text, _a) {\n  var fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds,\n    cellCount = _a.cellCount;\n  var line = mergeLines(cleanText(text));\n  if (line.length > cellCount) {\n    throw new CombedTextLayoutError(line.length, cellCount);\n  }\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n  }\n  var cellWidth = bounds.width / cellCount;\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  var cells = [];\n  var minX = bounds.x;\n  var minY = bounds.y;\n  var maxX = bounds.x + bounds.width;\n  var maxY = bounds.y + bounds.height;\n  var cellOffset = 0;\n  var charOffset = 0;\n  while (cellOffset < cellCount) {\n    var _b = charAtIndex(line, charOffset),\n      char = _b[0],\n      charLength = _b[1];\n    var encoded = font.encodeText(char);\n    var width = font.widthOfTextAtSize(char, fontSize);\n    var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n    var x = cellCenter - width / 2;\n    if (x < minX) minX = x;\n    if (y < minY) minY = y;\n    if (x + width > maxX) maxX = x + width;\n    if (y + height > maxY) maxY = y + height;\n    cells.push({\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    });\n    cellOffset += 1;\n    charOffset += charLength;\n  }\n  return {\n    fontSize: fontSize,\n    cells: cells,\n    bounds: {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    }\n  };\n};\nexport var layoutSinglelineText = function (text, _a) {\n  var alignment = _a.alignment,\n    fontSize = _a.fontSize,\n    font = _a.font,\n    bounds = _a.bounds;\n  var line = mergeLines(cleanText(text));\n  if (fontSize === undefined || fontSize === 0) {\n    fontSize = computeFontSize([line], font, bounds);\n  }\n  var encoded = font.encodeText(line);\n  var width = font.widthOfTextAtSize(line, fontSize);\n  var height = font.heightAtSize(fontSize, {\n    descender: false\n  });\n  // prettier-ignore\n  var x = alignment === TextAlignment.Left ? bounds.x : alignment === TextAlignment.Center ? bounds.x + bounds.width / 2 - width / 2 : alignment === TextAlignment.Right ? bounds.x + bounds.width - width : bounds.x;\n  var y = bounds.y + (bounds.height / 2 - height / 2);\n  return {\n    fontSize: fontSize,\n    line: {\n      text: line,\n      encoded: encoded,\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    },\n    bounds: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  };\n};","map":{"version":3,"sources":["../../../src/api/text/layout.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { CombedTextLayoutError } from \"../errors\";\nimport { TextAlignment } from \"./alignment\";\nimport { cleanText, lineSplit, mergeLines, charAtIndex, charSplit, } from \"../../utils\";\nvar MIN_FONT_SIZE = 4;\nvar MAX_FONT_SIZE = 500;\nvar computeFontSize = function (lines, font, bounds, multiline) {\n    if (multiline === void 0) { multiline = false; }\n    var fontSize = MIN_FONT_SIZE;\n    while (fontSize < MAX_FONT_SIZE) {\n        var linesUsed = 0;\n        for (var lineIdx = 0, lineLen = lines.length; lineIdx < lineLen; lineIdx++) {\n            linesUsed += 1;\n            var line = lines[lineIdx];\n            var words = line.split(' ');\n            // Layout the words using the current `fontSize`, line wrapping\n            // whenever we reach the end of the current line.\n            var spaceInLineRemaining = bounds.width;\n            for (var idx = 0, len = words.length; idx < len; idx++) {\n                var isLastWord = idx === len - 1;\n                var word = isLastWord ? words[idx] : words[idx] + ' ';\n                var widthOfWord = font.widthOfTextAtSize(word, fontSize);\n                spaceInLineRemaining -= widthOfWord;\n                if (spaceInLineRemaining <= 0) {\n                    linesUsed += 1;\n                    spaceInLineRemaining = bounds.width - widthOfWord;\n                }\n            }\n        }\n        // Return if we exceeded the allowed width\n        if (!multiline && linesUsed > lines.length)\n            return fontSize - 1;\n        var height = font.heightAtSize(fontSize);\n        var lineHeight = height + height * 0.2;\n        var totalHeight = lineHeight * linesUsed;\n        // Return if we exceeded the allowed height\n        if (totalHeight > Math.abs(bounds.height))\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar computeCombedFontSize = function (line, font, bounds, cellCount) {\n    var cellWidth = bounds.width / cellCount;\n    var cellHeight = bounds.height;\n    var fontSize = MIN_FONT_SIZE;\n    var chars = charSplit(line);\n    while (fontSize < MAX_FONT_SIZE) {\n        for (var idx = 0, len = chars.length; idx < len; idx++) {\n            var c = chars[idx];\n            var tooLong = font.widthOfTextAtSize(c, fontSize) > cellWidth * 0.75;\n            if (tooLong)\n                return fontSize - 1;\n        }\n        var height = font.heightAtSize(fontSize, { descender: false });\n        if (height > cellHeight)\n            return fontSize - 1;\n        fontSize += 1;\n    }\n    return fontSize;\n};\nvar lastIndexOfWhitespace = function (line) {\n    for (var idx = line.length; idx > 0; idx--) {\n        if (/\\s/.test(line[idx]))\n            return idx;\n    }\n    return undefined;\n};\nvar splitOutLines = function (input, maxWidth, font, fontSize) {\n    var _a;\n    var lastWhitespaceIdx = input.length;\n    while (lastWhitespaceIdx > 0) {\n        var line = input.substring(0, lastWhitespaceIdx);\n        var encoded = font.encodeText(line);\n        var width = font.widthOfTextAtSize(line, fontSize);\n        if (width < maxWidth) {\n            var remainder = input.substring(lastWhitespaceIdx) || undefined;\n            return { line: line, encoded: encoded, width: width, remainder: remainder };\n        }\n        lastWhitespaceIdx = (_a = lastIndexOfWhitespace(line)) !== null && _a !== void 0 ? _a : 0;\n    }\n    // We were unable to split the input enough to get a chunk that would fit\n    // within the specified `maxWidth` so we'll just return everything\n    return {\n        line: input,\n        encoded: font.encodeText(input),\n        width: font.widthOfTextAtSize(input, fontSize),\n        remainder: undefined,\n    };\n};\nexport var layoutMultilineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var lines = lineSplit(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeFontSize(lines, font, bounds, true);\n    }\n    var height = font.heightAtSize(fontSize);\n    var lineHeight = height + height * 0.2;\n    var textLines = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var y = bounds.y + bounds.height;\n    for (var idx = 0, len = lines.length; idx < len; idx++) {\n        var prevRemainder = lines[idx];\n        while (prevRemainder !== undefined) {\n            var _b = splitOutLines(prevRemainder, bounds.width, font, fontSize), line = _b.line, encoded = _b.encoded, width = _b.width, remainder = _b.remainder;\n            // prettier-ignore\n            var x = (alignment === TextAlignment.Left ? bounds.x\n                : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n                    : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                        : bounds.x);\n            y -= lineHeight;\n            if (x < minX)\n                minX = x;\n            if (y < minY)\n                minY = y;\n            if (x + width > maxX)\n                maxX = x + width;\n            if (y + height > maxY)\n                maxY = y + height;\n            textLines.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n            // Only trim lines that we had to split ourselves. So we won't trim lines\n            // that the user provided themselves with whitespace.\n            prevRemainder = remainder === null || remainder === void 0 ? void 0 : remainder.trim();\n        }\n    }\n    return {\n        fontSize: fontSize,\n        lineHeight: lineHeight,\n        lines: textLines,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutCombedText = function (text, _a) {\n    var fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds, cellCount = _a.cellCount;\n    var line = mergeLines(cleanText(text));\n    if (line.length > cellCount) {\n        throw new CombedTextLayoutError(line.length, cellCount);\n    }\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeCombedFontSize(line, font, bounds, cellCount);\n    }\n    var cellWidth = bounds.width / cellCount;\n    var height = font.heightAtSize(fontSize, { descender: false });\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    var cells = [];\n    var minX = bounds.x;\n    var minY = bounds.y;\n    var maxX = bounds.x + bounds.width;\n    var maxY = bounds.y + bounds.height;\n    var cellOffset = 0;\n    var charOffset = 0;\n    while (cellOffset < cellCount) {\n        var _b = charAtIndex(line, charOffset), char = _b[0], charLength = _b[1];\n        var encoded = font.encodeText(char);\n        var width = font.widthOfTextAtSize(char, fontSize);\n        var cellCenter = bounds.x + (cellWidth * cellOffset + cellWidth / 2);\n        var x = cellCenter - width / 2;\n        if (x < minX)\n            minX = x;\n        if (y < minY)\n            minY = y;\n        if (x + width > maxX)\n            maxX = x + width;\n        if (y + height > maxY)\n            maxY = y + height;\n        cells.push({ text: line, encoded: encoded, width: width, height: height, x: x, y: y });\n        cellOffset += 1;\n        charOffset += charLength;\n    }\n    return {\n        fontSize: fontSize,\n        cells: cells,\n        bounds: {\n            x: minX,\n            y: minY,\n            width: maxX - minX,\n            height: maxY - minY,\n        },\n    };\n};\nexport var layoutSinglelineText = function (text, _a) {\n    var alignment = _a.alignment, fontSize = _a.fontSize, font = _a.font, bounds = _a.bounds;\n    var line = mergeLines(cleanText(text));\n    if (fontSize === undefined || fontSize === 0) {\n        fontSize = computeFontSize([line], font, bounds);\n    }\n    var encoded = font.encodeText(line);\n    var width = font.widthOfTextAtSize(line, fontSize);\n    var height = font.heightAtSize(fontSize, { descender: false });\n    // prettier-ignore\n    var x = (alignment === TextAlignment.Left ? bounds.x\n        : alignment === TextAlignment.Center ? bounds.x + (bounds.width / 2) - (width / 2)\n            : alignment === TextAlignment.Right ? bounds.x + bounds.width - width\n                : bounds.x);\n    var y = bounds.y + (bounds.height / 2 - height / 2);\n    return {\n        fontSize: fontSize,\n        line: { text: line, encoded: encoded, width: width, height: height, x: x, y: y },\n        bounds: { x: x, y: y, width: width, height: height },\n    };\n};\n//# sourceMappingURL=layout.js.map"]},"metadata":{},"sourceType":"module"}