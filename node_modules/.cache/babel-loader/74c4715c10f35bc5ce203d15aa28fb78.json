{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFAcroField from \"./PDFAcroField\";\nimport PDFWidgetAnnotation from \"../annotation/PDFWidgetAnnotation\";\nimport { IndexOutOfBoundsError } from \"../errors\";\nvar PDFAcroTerminal = /** @class */function (_super) {\n  __extends(PDFAcroTerminal, _super);\n  function PDFAcroTerminal() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFAcroTerminal.prototype.FT = function () {\n    var nameOrRef = this.getInheritableAttribute(PDFName.of('FT'));\n    return this.dict.context.lookup(nameOrRef, PDFName);\n  };\n  PDFAcroTerminal.prototype.getWidgets = function () {\n    var kidDicts = this.Kids();\n    // This field is itself a widget\n    if (!kidDicts) return [PDFWidgetAnnotation.fromDict(this.dict)];\n    // This field's kids are its widgets\n    var widgets = new Array(kidDicts.size());\n    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n      var dict = kidDicts.lookup(idx, PDFDict);\n      widgets[idx] = PDFWidgetAnnotation.fromDict(dict);\n    }\n    return widgets;\n  };\n  PDFAcroTerminal.prototype.addWidget = function (ref) {\n    var Kids = this.normalizedEntries().Kids;\n    Kids.push(ref);\n  };\n  PDFAcroTerminal.prototype.removeWidget = function (idx) {\n    var kidDicts = this.Kids();\n    if (!kidDicts) {\n      // This field is itself a widget\n      if (idx !== 0) throw new IndexOutOfBoundsError(idx, 0, 0);\n      this.setKids([]);\n    } else {\n      // This field's kids are its widgets\n      if (idx < 0 || idx > kidDicts.size()) {\n        throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());\n      }\n      kidDicts.remove(idx);\n    }\n  };\n  PDFAcroTerminal.prototype.normalizedEntries = function () {\n    var Kids = this.Kids();\n    // If this field is itself a widget (because it was only rendered once in\n    // the document, so the field and widget properties were merged) then we\n    // add itself to the `Kids` array. The alternative would be to try\n    // splitting apart the widget properties and creating a separate object\n    // for them.\n    if (!Kids) {\n      Kids = this.dict.context.obj([this.ref]);\n      this.dict.set(PDFName.of('Kids'), Kids);\n    }\n    return {\n      Kids: Kids\n    };\n  };\n  PDFAcroTerminal.fromDict = function (dict, ref) {\n    return new PDFAcroTerminal(dict, ref);\n  };\n  return PDFAcroTerminal;\n}(PDFAcroField);\nexport default PDFAcroTerminal;","map":{"version":3,"sources":["../../../src/core/acroform/PDFAcroTerminal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFAcroField from \"./PDFAcroField\";\nimport PDFWidgetAnnotation from \"../annotation/PDFWidgetAnnotation\";\nimport { IndexOutOfBoundsError } from \"../errors\";\nvar PDFAcroTerminal = /** @class */ (function (_super) {\n    __extends(PDFAcroTerminal, _super);\n    function PDFAcroTerminal() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PDFAcroTerminal.prototype.FT = function () {\n        var nameOrRef = this.getInheritableAttribute(PDFName.of('FT'));\n        return this.dict.context.lookup(nameOrRef, PDFName);\n    };\n    PDFAcroTerminal.prototype.getWidgets = function () {\n        var kidDicts = this.Kids();\n        // This field is itself a widget\n        if (!kidDicts)\n            return [PDFWidgetAnnotation.fromDict(this.dict)];\n        // This field's kids are its widgets\n        var widgets = new Array(kidDicts.size());\n        for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n            var dict = kidDicts.lookup(idx, PDFDict);\n            widgets[idx] = PDFWidgetAnnotation.fromDict(dict);\n        }\n        return widgets;\n    };\n    PDFAcroTerminal.prototype.addWidget = function (ref) {\n        var Kids = this.normalizedEntries().Kids;\n        Kids.push(ref);\n    };\n    PDFAcroTerminal.prototype.removeWidget = function (idx) {\n        var kidDicts = this.Kids();\n        if (!kidDicts) {\n            // This field is itself a widget\n            if (idx !== 0)\n                throw new IndexOutOfBoundsError(idx, 0, 0);\n            this.setKids([]);\n        }\n        else {\n            // This field's kids are its widgets\n            if (idx < 0 || idx > kidDicts.size()) {\n                throw new IndexOutOfBoundsError(idx, 0, kidDicts.size());\n            }\n            kidDicts.remove(idx);\n        }\n    };\n    PDFAcroTerminal.prototype.normalizedEntries = function () {\n        var Kids = this.Kids();\n        // If this field is itself a widget (because it was only rendered once in\n        // the document, so the field and widget properties were merged) then we\n        // add itself to the `Kids` array. The alternative would be to try\n        // splitting apart the widget properties and creating a separate object\n        // for them.\n        if (!Kids) {\n            Kids = this.dict.context.obj([this.ref]);\n            this.dict.set(PDFName.of('Kids'), Kids);\n        }\n        return { Kids: Kids };\n    };\n    PDFAcroTerminal.fromDict = function (dict, ref) {\n        return new PDFAcroTerminal(dict, ref);\n    };\n    return PDFAcroTerminal;\n}(PDFAcroField));\nexport default PDFAcroTerminal;\n//# sourceMappingURL=PDFAcroTerminal.js.map"]},"metadata":{},"sourceType":"module"}