{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\nvar PDFWriter = /** @class */function () {\n  function PDFWriter(context, objectsPerTick) {\n    var _this = this;\n    this.parsedObjects = 0;\n    this.shouldWaitForTick = function (n) {\n      _this.parsedObjects += n;\n      return _this.parsedObjects % _this.objectsPerTick === 0;\n    };\n    this.context = context;\n    this.objectsPerTick = objectsPerTick;\n  }\n  PDFWriter.prototype.serializeToBuffer = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4 /*yield*/, this.computeBufferSize()];\n          case 1:\n            _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n            offset = 0;\n            buffer = new Uint8Array(size);\n            offset += header.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            idx = 0, len = indirectObjects.length;\n            _c.label = 2;\n          case 2:\n            if (!(idx < len)) return [3 /*break*/, 5];\n            _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n            objectNumber = String(ref.objectNumber);\n            offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            generationNumber = String(ref.generationNumber);\n            offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n            buffer[offset++] = CharCodes.Space;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            offset += object.copyBytesInto(buffer, offset);\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.e;\n            buffer[offset++] = CharCodes.n;\n            buffer[offset++] = CharCodes.d;\n            buffer[offset++] = CharCodes.o;\n            buffer[offset++] = CharCodes.b;\n            buffer[offset++] = CharCodes.j;\n            buffer[offset++] = CharCodes.Newline;\n            buffer[offset++] = CharCodes.Newline;\n            n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n            if (!this.shouldWaitForTick(n)) return [3 /*break*/, 4];\n            return [4 /*yield*/, waitForTick()];\n          case 3:\n            _c.sent();\n            _c.label = 4;\n          case 4:\n            idx++;\n            return [3 /*break*/, 2];\n          case 5:\n            if (xref) {\n              offset += xref.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n            }\n            if (trailerDict) {\n              offset += trailerDict.copyBytesInto(buffer, offset);\n              buffer[offset++] = CharCodes.Newline;\n              buffer[offset++] = CharCodes.Newline;\n            }\n            offset += trailer.copyBytesInto(buffer, offset);\n            return [2 /*return*/, buffer];\n        }\n      });\n    });\n  };\n  PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n    var ref = _a[0],\n      object = _a[1];\n    var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n    var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n    return refSize + objectSize;\n  };\n  PDFWriter.prototype.createTrailerDict = function () {\n    return this.context.obj({\n      Size: this.context.largestObjectNumber + 1,\n      Root: this.context.trailerInfo.Root,\n      Encrypt: this.context.trailerInfo.Encrypt,\n      Info: this.context.trailerInfo.Info,\n      ID: this.context.trailerInfo.ID\n    });\n  };\n  PDFWriter.prototype.computeBufferSize = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            header = PDFHeader.forVersion(1, 7);\n            size = header.sizeInBytes() + 2;\n            xref = PDFCrossRefSection.create();\n            indirectObjects = this.context.enumerateIndirectObjects();\n            idx = 0, len = indirectObjects.length;\n            _a.label = 1;\n          case 1:\n            if (!(idx < len)) return [3 /*break*/, 4];\n            indirectObject = indirectObjects[idx];\n            ref = indirectObject[0];\n            xref.addEntry(ref, size);\n            size += this.computeIndirectObjectSize(indirectObject);\n            if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n            return [4 /*yield*/, waitForTick()];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            idx++;\n            return [3 /*break*/, 1];\n          case 4:\n            xrefOffset = size;\n            size += xref.sizeInBytes() + 1; // '\\n'\n            trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n            size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n            trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n            size += trailer.sizeInBytes();\n            return [2 /*return*/, {\n              size: size,\n              header: header,\n              indirectObjects: indirectObjects,\n              xref: xref,\n              trailerDict: trailerDict,\n              trailer: trailer\n            }];\n        }\n      });\n    });\n  };\n  PDFWriter.forContext = function (context, objectsPerTick) {\n    return new PDFWriter(context, objectsPerTick);\n  };\n  return PDFWriter;\n}();\nexport default PDFWriter;","map":{"version":3,"sources":["../../../src/core/writers/PDFWriter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter, __generator } from \"tslib\";\nimport PDFCrossRefSection from \"../document/PDFCrossRefSection\";\nimport PDFHeader from \"../document/PDFHeader\";\nimport PDFTrailer from \"../document/PDFTrailer\";\nimport PDFTrailerDict from \"../document/PDFTrailerDict\";\nimport PDFObjectStream from \"../structures/PDFObjectStream\";\nimport CharCodes from \"../syntax/CharCodes\";\nimport { copyStringIntoBuffer, waitForTick } from \"../../utils\";\nvar PDFWriter = /** @class */ (function () {\n    function PDFWriter(context, objectsPerTick) {\n        var _this = this;\n        this.parsedObjects = 0;\n        this.shouldWaitForTick = function (n) {\n            _this.parsedObjects += n;\n            return _this.parsedObjects % _this.objectsPerTick === 0;\n        };\n        this.context = context;\n        this.objectsPerTick = objectsPerTick;\n    }\n    PDFWriter.prototype.serializeToBuffer = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, size, header, indirectObjects, xref, trailerDict, trailer, offset, buffer, idx, len, _b, ref, object, objectNumber, generationNumber, n;\n            return __generator(this, function (_c) {\n                switch (_c.label) {\n                    case 0: return [4 /*yield*/, this.computeBufferSize()];\n                    case 1:\n                        _a = _c.sent(), size = _a.size, header = _a.header, indirectObjects = _a.indirectObjects, xref = _a.xref, trailerDict = _a.trailerDict, trailer = _a.trailer;\n                        offset = 0;\n                        buffer = new Uint8Array(size);\n                        offset += header.copyBytesInto(buffer, offset);\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.Newline;\n                        idx = 0, len = indirectObjects.length;\n                        _c.label = 2;\n                    case 2:\n                        if (!(idx < len)) return [3 /*break*/, 5];\n                        _b = indirectObjects[idx], ref = _b[0], object = _b[1];\n                        objectNumber = String(ref.objectNumber);\n                        offset += copyStringIntoBuffer(objectNumber, buffer, offset);\n                        buffer[offset++] = CharCodes.Space;\n                        generationNumber = String(ref.generationNumber);\n                        offset += copyStringIntoBuffer(generationNumber, buffer, offset);\n                        buffer[offset++] = CharCodes.Space;\n                        buffer[offset++] = CharCodes.o;\n                        buffer[offset++] = CharCodes.b;\n                        buffer[offset++] = CharCodes.j;\n                        buffer[offset++] = CharCodes.Newline;\n                        offset += object.copyBytesInto(buffer, offset);\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.e;\n                        buffer[offset++] = CharCodes.n;\n                        buffer[offset++] = CharCodes.d;\n                        buffer[offset++] = CharCodes.o;\n                        buffer[offset++] = CharCodes.b;\n                        buffer[offset++] = CharCodes.j;\n                        buffer[offset++] = CharCodes.Newline;\n                        buffer[offset++] = CharCodes.Newline;\n                        n = object instanceof PDFObjectStream ? object.getObjectsCount() : 1;\n                        if (!this.shouldWaitForTick(n)) return [3 /*break*/, 4];\n                        return [4 /*yield*/, waitForTick()];\n                    case 3:\n                        _c.sent();\n                        _c.label = 4;\n                    case 4:\n                        idx++;\n                        return [3 /*break*/, 2];\n                    case 5:\n                        if (xref) {\n                            offset += xref.copyBytesInto(buffer, offset);\n                            buffer[offset++] = CharCodes.Newline;\n                        }\n                        if (trailerDict) {\n                            offset += trailerDict.copyBytesInto(buffer, offset);\n                            buffer[offset++] = CharCodes.Newline;\n                            buffer[offset++] = CharCodes.Newline;\n                        }\n                        offset += trailer.copyBytesInto(buffer, offset);\n                        return [2 /*return*/, buffer];\n                }\n            });\n        });\n    };\n    PDFWriter.prototype.computeIndirectObjectSize = function (_a) {\n        var ref = _a[0], object = _a[1];\n        var refSize = ref.sizeInBytes() + 3; // 'R' -> 'obj\\n'\n        var objectSize = object.sizeInBytes() + 9; // '\\nendobj\\n\\n'\n        return refSize + objectSize;\n    };\n    PDFWriter.prototype.createTrailerDict = function () {\n        return this.context.obj({\n            Size: this.context.largestObjectNumber + 1,\n            Root: this.context.trailerInfo.Root,\n            Encrypt: this.context.trailerInfo.Encrypt,\n            Info: this.context.trailerInfo.Info,\n            ID: this.context.trailerInfo.ID,\n        });\n    };\n    PDFWriter.prototype.computeBufferSize = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var header, size, xref, indirectObjects, idx, len, indirectObject, ref, xrefOffset, trailerDict, trailer;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        header = PDFHeader.forVersion(1, 7);\n                        size = header.sizeInBytes() + 2;\n                        xref = PDFCrossRefSection.create();\n                        indirectObjects = this.context.enumerateIndirectObjects();\n                        idx = 0, len = indirectObjects.length;\n                        _a.label = 1;\n                    case 1:\n                        if (!(idx < len)) return [3 /*break*/, 4];\n                        indirectObject = indirectObjects[idx];\n                        ref = indirectObject[0];\n                        xref.addEntry(ref, size);\n                        size += this.computeIndirectObjectSize(indirectObject);\n                        if (!this.shouldWaitForTick(1)) return [3 /*break*/, 3];\n                        return [4 /*yield*/, waitForTick()];\n                    case 2:\n                        _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        idx++;\n                        return [3 /*break*/, 1];\n                    case 4:\n                        xrefOffset = size;\n                        size += xref.sizeInBytes() + 1; // '\\n'\n                        trailerDict = PDFTrailerDict.of(this.createTrailerDict());\n                        size += trailerDict.sizeInBytes() + 2; // '\\n\\n'\n                        trailer = PDFTrailer.forLastCrossRefSectionOffset(xrefOffset);\n                        size += trailer.sizeInBytes();\n                        return [2 /*return*/, { size: size, header: header, indirectObjects: indirectObjects, xref: xref, trailerDict: trailerDict, trailer: trailer }];\n                }\n            });\n        });\n    };\n    PDFWriter.forContext = function (context, objectsPerTick) {\n        return new PDFWriter(context, objectsPerTick);\n    };\n    return PDFWriter;\n}());\nexport default PDFWriter;\n//# sourceMappingURL=PDFWriter.js.map"]},"metadata":{},"sourceType":"module"}