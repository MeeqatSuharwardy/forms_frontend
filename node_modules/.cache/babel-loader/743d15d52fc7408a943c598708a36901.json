{"ast":null,"code":"import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */function (_super) {\n  __extends(PDFPageTree, _super);\n  function PDFPageTree() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PDFPageTree.prototype.Parent = function () {\n    return this.lookup(PDFName.of('Parent'));\n  };\n  PDFPageTree.prototype.Kids = function () {\n    return this.lookup(PDFName.of('Kids'), PDFArray);\n  };\n  PDFPageTree.prototype.Count = function () {\n    return this.lookup(PDFName.of('Count'), PDFNumber);\n  };\n  PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n    var Kids = this.Kids();\n    Kids.push(treeRef);\n  };\n  PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n    var Kids = this.Kids();\n    this.insertLeafKid(Kids.size(), leafRef);\n  };\n  /**\n   * Inserts the given ref as a leaf node of this page tree at the specified\n   * index (zero-based). Also increments the `Count` of each page tree in the\n   * hierarchy to accomodate the new page.\n   *\n   * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n   * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n   * which the method was first called).\n   */\n  PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex > Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      if (leafsRemainingUntilTarget === 0) {\n        // Insert page and return\n        this.insertLeafKid(idx, leafRef);\n        return undefined;\n      }\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          return kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        // Move on\n        leafsRemainingUntilTarget -= 1;\n      }\n    }\n    if (leafsRemainingUntilTarget === 0) {\n      // Insert page at the end and return\n      this.insertLeafKid(Kids.size(), leafRef);\n      return undefined;\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n  };\n  /**\n   * Removes the leaf node at the specified index (zero-based) from this page\n   * tree. Also decrements the `Count` of each page tree in the hierarchy to\n   * account for the removed page.\n   *\n   * If `prune` is true, then intermediate tree nodes will be removed from the\n   * tree if they contain 0 children after the leaf node is removed.\n   */\n  PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n    if (prune === void 0) {\n      prune = true;\n    }\n    var Kids = this.Kids();\n    var Count = this.Count().asNumber();\n    if (targetIndex >= Count) {\n      throw new InvalidTargetIndexError(targetIndex, Count);\n    }\n    var leafsRemainingUntilTarget = targetIndex;\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) {\n        if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n          // Dig in\n          kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n          if (prune && kid.Kids().size() === 0) Kids.remove(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= kid.Count().asNumber();\n        }\n      }\n      if (kid instanceof PDFPageLeaf) {\n        if (leafsRemainingUntilTarget === 0) {\n          // Remove page and return\n          this.removeKid(idx);\n          return;\n        } else {\n          // Move on\n          leafsRemainingUntilTarget -= 1;\n        }\n      }\n    }\n    // Should never get here if `targetIndex` is valid\n    throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n  };\n  PDFPageTree.prototype.ascend = function (visitor) {\n    visitor(this);\n    var Parent = this.Parent();\n    if (Parent) Parent.ascend(visitor);\n  };\n  /** Performs a Post-Order traversal of this page tree */\n  PDFPageTree.prototype.traverse = function (visitor) {\n    var Kids = this.Kids();\n    for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n      var kidRef = Kids.get(idx);\n      var kid = this.context.lookup(kidRef);\n      if (kid instanceof PDFPageTree) kid.traverse(visitor);\n      visitor(kid, kidRef);\n    }\n  };\n  PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n    var Kids = this.Kids();\n    this.ascend(function (node) {\n      var newCount = node.Count().asNumber() + 1;\n      node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n    });\n    Kids.insert(kidIdx, leafRef);\n  };\n  PDFPageTree.prototype.removeKid = function (kidIdx) {\n    var Kids = this.Kids();\n    var kid = Kids.lookup(kidIdx);\n    if (kid instanceof PDFPageLeaf) {\n      this.ascend(function (node) {\n        var newCount = node.Count().asNumber() - 1;\n        node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n      });\n    }\n    Kids.remove(kidIdx);\n  };\n  PDFPageTree.withContext = function (context, parent) {\n    var dict = new Map();\n    dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n    dict.set(PDFName.of('Kids'), context.obj([]));\n    dict.set(PDFName.of('Count'), context.obj(0));\n    if (parent) dict.set(PDFName.of('Parent'), parent);\n    return new PDFPageTree(dict, context);\n  };\n  PDFPageTree.fromMapWithContext = function (map, context) {\n    return new PDFPageTree(map, context);\n  };\n  return PDFPageTree;\n}(PDFDict);\nexport default PDFPageTree;","map":{"version":3,"sources":["../../../src/core/structures/PDFPageTree.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __extends } from \"tslib\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFNumber from \"../objects/PDFNumber\";\nimport PDFPageLeaf from \"./PDFPageLeaf\";\nimport { InvalidTargetIndexError, CorruptPageTreeError } from \"../errors\";\nvar PDFPageTree = /** @class */ (function (_super) {\n    __extends(PDFPageTree, _super);\n    function PDFPageTree() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PDFPageTree.prototype.Parent = function () {\n        return this.lookup(PDFName.of('Parent'));\n    };\n    PDFPageTree.prototype.Kids = function () {\n        return this.lookup(PDFName.of('Kids'), PDFArray);\n    };\n    PDFPageTree.prototype.Count = function () {\n        return this.lookup(PDFName.of('Count'), PDFNumber);\n    };\n    PDFPageTree.prototype.pushTreeNode = function (treeRef) {\n        var Kids = this.Kids();\n        Kids.push(treeRef);\n    };\n    PDFPageTree.prototype.pushLeafNode = function (leafRef) {\n        var Kids = this.Kids();\n        this.insertLeafKid(Kids.size(), leafRef);\n    };\n    /**\n     * Inserts the given ref as a leaf node of this page tree at the specified\n     * index (zero-based). Also increments the `Count` of each page tree in the\n     * hierarchy to accomodate the new page.\n     *\n     * Returns the ref of the PDFPageTree node into which `leafRef` was inserted,\n     * or `undefined` if it was inserted into the root node (the PDFPageTree upon\n     * which the method was first called).\n     */\n    PDFPageTree.prototype.insertLeafNode = function (leafRef, targetIndex) {\n        var Kids = this.Kids();\n        var Count = this.Count().asNumber();\n        if (targetIndex > Count) {\n            throw new InvalidTargetIndexError(targetIndex, Count);\n        }\n        var leafsRemainingUntilTarget = targetIndex;\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            if (leafsRemainingUntilTarget === 0) {\n                // Insert page and return\n                this.insertLeafKid(idx, leafRef);\n                return undefined;\n            }\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree) {\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n                    // Dig in\n                    return (kid.insertLeafNode(leafRef, leafsRemainingUntilTarget) || kidRef);\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\n                }\n            }\n            if (kid instanceof PDFPageLeaf) {\n                // Move on\n                leafsRemainingUntilTarget -= 1;\n            }\n        }\n        if (leafsRemainingUntilTarget === 0) {\n            // Insert page at the end and return\n            this.insertLeafKid(Kids.size(), leafRef);\n            return undefined;\n        }\n        // Should never get here if `targetIndex` is valid\n        throw new CorruptPageTreeError(targetIndex, 'insertLeafNode');\n    };\n    /**\n     * Removes the leaf node at the specified index (zero-based) from this page\n     * tree. Also decrements the `Count` of each page tree in the hierarchy to\n     * account for the removed page.\n     *\n     * If `prune` is true, then intermediate tree nodes will be removed from the\n     * tree if they contain 0 children after the leaf node is removed.\n     */\n    PDFPageTree.prototype.removeLeafNode = function (targetIndex, prune) {\n        if (prune === void 0) { prune = true; }\n        var Kids = this.Kids();\n        var Count = this.Count().asNumber();\n        if (targetIndex >= Count) {\n            throw new InvalidTargetIndexError(targetIndex, Count);\n        }\n        var leafsRemainingUntilTarget = targetIndex;\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree) {\n                if (kid.Count().asNumber() > leafsRemainingUntilTarget) {\n                    // Dig in\n                    kid.removeLeafNode(leafsRemainingUntilTarget, prune);\n                    if (prune && kid.Kids().size() === 0)\n                        Kids.remove(idx);\n                    return;\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= kid.Count().asNumber();\n                }\n            }\n            if (kid instanceof PDFPageLeaf) {\n                if (leafsRemainingUntilTarget === 0) {\n                    // Remove page and return\n                    this.removeKid(idx);\n                    return;\n                }\n                else {\n                    // Move on\n                    leafsRemainingUntilTarget -= 1;\n                }\n            }\n        }\n        // Should never get here if `targetIndex` is valid\n        throw new CorruptPageTreeError(targetIndex, 'removeLeafNode');\n    };\n    PDFPageTree.prototype.ascend = function (visitor) {\n        visitor(this);\n        var Parent = this.Parent();\n        if (Parent)\n            Parent.ascend(visitor);\n    };\n    /** Performs a Post-Order traversal of this page tree */\n    PDFPageTree.prototype.traverse = function (visitor) {\n        var Kids = this.Kids();\n        for (var idx = 0, len = Kids.size(); idx < len; idx++) {\n            var kidRef = Kids.get(idx);\n            var kid = this.context.lookup(kidRef);\n            if (kid instanceof PDFPageTree)\n                kid.traverse(visitor);\n            visitor(kid, kidRef);\n        }\n    };\n    PDFPageTree.prototype.insertLeafKid = function (kidIdx, leafRef) {\n        var Kids = this.Kids();\n        this.ascend(function (node) {\n            var newCount = node.Count().asNumber() + 1;\n            node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n        });\n        Kids.insert(kidIdx, leafRef);\n    };\n    PDFPageTree.prototype.removeKid = function (kidIdx) {\n        var Kids = this.Kids();\n        var kid = Kids.lookup(kidIdx);\n        if (kid instanceof PDFPageLeaf) {\n            this.ascend(function (node) {\n                var newCount = node.Count().asNumber() - 1;\n                node.set(PDFName.of('Count'), PDFNumber.of(newCount));\n            });\n        }\n        Kids.remove(kidIdx);\n    };\n    PDFPageTree.withContext = function (context, parent) {\n        var dict = new Map();\n        dict.set(PDFName.of('Type'), PDFName.of('Pages'));\n        dict.set(PDFName.of('Kids'), context.obj([]));\n        dict.set(PDFName.of('Count'), context.obj(0));\n        if (parent)\n            dict.set(PDFName.of('Parent'), parent);\n        return new PDFPageTree(dict, context);\n    };\n    PDFPageTree.fromMapWithContext = function (map, context) {\n        return new PDFPageTree(map, context);\n    };\n    return PDFPageTree;\n}(PDFDict));\nexport default PDFPageTree;\n//# sourceMappingURL=PDFPageTree.js.map"]},"metadata":{},"sourceType":"module"}