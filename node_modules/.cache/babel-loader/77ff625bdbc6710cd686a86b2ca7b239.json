{"ast":null,"code":"import PDFNumber from \"../objects/PDFNumber\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport PDFAcroNonTerminal from \"./PDFAcroNonTerminal\";\nimport PDFAcroSignature from \"./PDFAcroSignature\";\nimport PDFAcroText from \"./PDFAcroText\";\nimport PDFAcroPushButton from \"./PDFAcroPushButton\";\nimport PDFAcroRadioButton from \"./PDFAcroRadioButton\";\nimport PDFAcroCheckBox from \"./PDFAcroCheckBox\";\nimport PDFAcroComboBox from \"./PDFAcroComboBox\";\nimport PDFAcroListBox from \"./PDFAcroListBox\";\nimport { AcroButtonFlags, AcroChoiceFlags } from \"./flags\";\nexport var createPDFAcroFields = function (kidDicts) {\n  if (!kidDicts) return [];\n  var kids = [];\n  for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n    var ref = kidDicts.get(idx);\n    var dict = kidDicts.lookup(idx);\n    // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n    if (ref instanceof PDFRef && dict instanceof PDFDict) {\n      kids.push([createPDFAcroField(dict, ref), ref]);\n    }\n  }\n  return kids;\n};\nexport var createPDFAcroField = function (dict, ref) {\n  var isNonTerminal = isNonTerminalAcroField(dict);\n  if (isNonTerminal) return PDFAcroNonTerminal.fromDict(dict, ref);\n  return createPDFAcroTerminal(dict, ref);\n};\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nvar isNonTerminalAcroField = function (dict) {\n  var kids = dict.lookup(PDFName.of('Kids'));\n  if (kids instanceof PDFArray) {\n    for (var idx = 0, len = kids.size(); idx < len; idx++) {\n      var kid = kids.lookup(idx);\n      var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n      if (kidIsField) return true;\n    }\n  }\n  return false;\n};\nvar createPDFAcroTerminal = function (dict, ref) {\n  var ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n  var type = dict.context.lookup(ftNameOrRef, PDFName);\n  if (type === PDFName.of('Btn')) return createPDFAcroButton(dict, ref);\n  if (type === PDFName.of('Ch')) return createPDFAcroChoice(dict, ref);\n  if (type === PDFName.of('Tx')) return PDFAcroText.fromDict(dict, ref);\n  if (type === PDFName.of('Sig')) return PDFAcroSignature.fromDict(dict, ref);\n  // We should never reach this line. But there are a lot of weird PDFs out\n  // there. So, just to be safe, we'll try to handle things gracefully instead\n  // of throwing an error.\n  return PDFAcroTerminal.fromDict(dict, ref);\n};\nvar createPDFAcroButton = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n    return PDFAcroPushButton.fromDict(dict, ref);\n  } else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n    return PDFAcroRadioButton.fromDict(dict, ref);\n  } else {\n    return PDFAcroCheckBox.fromDict(dict, ref);\n  }\n};\nvar createPDFAcroChoice = function (dict, ref) {\n  var _a;\n  var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n  var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n  var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n  if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n    return PDFAcroComboBox.fromDict(dict, ref);\n  } else {\n    return PDFAcroListBox.fromDict(dict, ref);\n  }\n};\nvar flagIsSet = function (flags, flag) {\n  return (flags & flag) !== 0;\n};\nvar getInheritableAttribute = function (startNode, name) {\n  var attribute;\n  ascend(startNode, function (node) {\n    if (!attribute) attribute = node.get(name);\n  });\n  return attribute;\n};\nvar ascend = function (startNode, visitor) {\n  visitor(startNode);\n  var Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n  if (Parent) ascend(Parent, visitor);\n};","map":{"version":3,"sources":["../../../src/core/acroform/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import PDFNumber from \"../objects/PDFNumber\";\nimport PDFDict from \"../objects/PDFDict\";\nimport PDFName from \"../objects/PDFName\";\nimport PDFArray from \"../objects/PDFArray\";\nimport PDFRef from \"../objects/PDFRef\";\nimport PDFAcroTerminal from \"./PDFAcroTerminal\";\nimport PDFAcroNonTerminal from \"./PDFAcroNonTerminal\";\nimport PDFAcroSignature from \"./PDFAcroSignature\";\nimport PDFAcroText from \"./PDFAcroText\";\nimport PDFAcroPushButton from \"./PDFAcroPushButton\";\nimport PDFAcroRadioButton from \"./PDFAcroRadioButton\";\nimport PDFAcroCheckBox from \"./PDFAcroCheckBox\";\nimport PDFAcroComboBox from \"./PDFAcroComboBox\";\nimport PDFAcroListBox from \"./PDFAcroListBox\";\nimport { AcroButtonFlags, AcroChoiceFlags } from \"./flags\";\nexport var createPDFAcroFields = function (kidDicts) {\n    if (!kidDicts)\n        return [];\n    var kids = [];\n    for (var idx = 0, len = kidDicts.size(); idx < len; idx++) {\n        var ref = kidDicts.get(idx);\n        var dict = kidDicts.lookup(idx);\n        // if (dict instanceof PDFDict) kids.push(PDFAcroField.fromDict(dict));\n        if (ref instanceof PDFRef && dict instanceof PDFDict) {\n            kids.push([createPDFAcroField(dict, ref), ref]);\n        }\n    }\n    return kids;\n};\nexport var createPDFAcroField = function (dict, ref) {\n    var isNonTerminal = isNonTerminalAcroField(dict);\n    if (isNonTerminal)\n        return PDFAcroNonTerminal.fromDict(dict, ref);\n    return createPDFAcroTerminal(dict, ref);\n};\n// TODO: Maybe just check if the dict is *not* a widget? That might be better.\n// According to the PDF spec:\n//\n//   > A field's children in the hierarchy may also include widget annotations\n//   > that define its appearance on the page. A field that has children that\n//   > are fields is called a non-terminal field. A field that does not have\n//   > children that are fields is called a terminal field.\n//\n// The spec is not entirely clear about how to determine whether a given\n// dictionary represents an acrofield or a widget annotation. So we will assume\n// that a dictionary is an acrofield if it is a member of the `/Kids` array\n// and it contains a `/T` entry (widgets do not have `/T` entries). This isn't\n// a bullet proof solution, because the `/T` entry is technically defined as\n// optional for acrofields by the PDF spec. But in practice all acrofields seem\n// to have a `/T` entry defined.\nvar isNonTerminalAcroField = function (dict) {\n    var kids = dict.lookup(PDFName.of('Kids'));\n    if (kids instanceof PDFArray) {\n        for (var idx = 0, len = kids.size(); idx < len; idx++) {\n            var kid = kids.lookup(idx);\n            var kidIsField = kid instanceof PDFDict && kid.has(PDFName.of('T'));\n            if (kidIsField)\n                return true;\n        }\n    }\n    return false;\n};\nvar createPDFAcroTerminal = function (dict, ref) {\n    var ftNameOrRef = getInheritableAttribute(dict, PDFName.of('FT'));\n    var type = dict.context.lookup(ftNameOrRef, PDFName);\n    if (type === PDFName.of('Btn'))\n        return createPDFAcroButton(dict, ref);\n    if (type === PDFName.of('Ch'))\n        return createPDFAcroChoice(dict, ref);\n    if (type === PDFName.of('Tx'))\n        return PDFAcroText.fromDict(dict, ref);\n    if (type === PDFName.of('Sig'))\n        return PDFAcroSignature.fromDict(dict, ref);\n    // We should never reach this line. But there are a lot of weird PDFs out\n    // there. So, just to be safe, we'll try to handle things gracefully instead\n    // of throwing an error.\n    return PDFAcroTerminal.fromDict(dict, ref);\n};\nvar createPDFAcroButton = function (dict, ref) {\n    var _a;\n    var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n    if (flagIsSet(flags, AcroButtonFlags.PushButton)) {\n        return PDFAcroPushButton.fromDict(dict, ref);\n    }\n    else if (flagIsSet(flags, AcroButtonFlags.Radio)) {\n        return PDFAcroRadioButton.fromDict(dict, ref);\n    }\n    else {\n        return PDFAcroCheckBox.fromDict(dict, ref);\n    }\n};\nvar createPDFAcroChoice = function (dict, ref) {\n    var _a;\n    var ffNumberOrRef = getInheritableAttribute(dict, PDFName.of('Ff'));\n    var ffNumber = dict.context.lookupMaybe(ffNumberOrRef, PDFNumber);\n    var flags = (_a = ffNumber === null || ffNumber === void 0 ? void 0 : ffNumber.asNumber()) !== null && _a !== void 0 ? _a : 0;\n    if (flagIsSet(flags, AcroChoiceFlags.Combo)) {\n        return PDFAcroComboBox.fromDict(dict, ref);\n    }\n    else {\n        return PDFAcroListBox.fromDict(dict, ref);\n    }\n};\nvar flagIsSet = function (flags, flag) {\n    return (flags & flag) !== 0;\n};\nvar getInheritableAttribute = function (startNode, name) {\n    var attribute;\n    ascend(startNode, function (node) {\n        if (!attribute)\n            attribute = node.get(name);\n    });\n    return attribute;\n};\nvar ascend = function (startNode, visitor) {\n    visitor(startNode);\n    var Parent = startNode.lookupMaybe(PDFName.of('Parent'), PDFDict);\n    if (Parent)\n        ascend(Parent, visitor);\n};\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}